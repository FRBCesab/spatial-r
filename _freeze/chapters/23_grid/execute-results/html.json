{
  "hash": "1ff3a55e735a1d65400227c5c691fe96",
  "result": {
    "engine": "knitr",
    "markdown": "# Grid {.unnumbered}\n\n:::{.callout-important title=\"Summary\"}\nThis tutorial explores how to create a regular grid and transform spatial informations into a grid with `terra` package:\n\n- project spatial data to a commun CRS with [`terra::project()`](https://search.r-project.org/CRAN/refmans/terra/html/project.html)   \n- transform vectors to raster with [`terra::rasterize()`](https://search.r-project.org/CRAN/refmans/terra/html/rasterize.html)\n- match different raster grids with [`terra::resample()`](https://search.r-project.org/CRAN/refmans/terra/html/resample.html)\n:::\n\n\n:::{.callout-tip title=\"The ecologist mind\"}\nFor modeling, it is often needed to get all spatial data into a commun grid. For instance, among the spatial informations that we have seen in the previous chapter, which factors explain best the number of observations of otters?\n:::\n\n\n## Setup\n\n<details>\n<summary> Follow the setup instructions if you haven't followed previous tutorials</summary>\n\nIf haven't done it already, please follow the [setup instructions](https://frbcesab.github.io/spatial-r/chapters/01_setup.html).    \n\nLet's start with loading the required packages.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages({\n  library(mapview)\n  library(here)\n  library(terra)\n})\n```\n:::\n\n\n\n\nNow load all the datasets attached to the observations of otters recorded in 2021 within a 50km buffer from Montpellier, France.  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npt_otter <- vect(here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\nriver <- vect(here(\"data\", \"BDCARTO-River_mpl50km.gpkg\"))\nlanduse <- vect(here(\"data\", \"BDCARTO-LULC_mpl50km.shp\"))\nbdalti <- rast(here(\"data\", \"BDALTI_mpl50km.tif\"))\ntemperature <- rast(here(\"data\", \"CHELSA_monthly_tas_2015_2021.tif\"))\n```\n:::\n\n\n\n\n</details>\n\n## Create a grid\n\nCreating a grid requires a defined spatial resolution and a projection system. These choices depend on your dataset, its extent, and your modeling objectives.   \n\nIn our case, we will create a grid of 5km around the otters observations using the Lambert-93 projection ([EPSG:2154](https://epsg.io/2154)). \n\nThe function [`terra::rast()`](https://search.r-project.org/CRAN/refmans/terra/html/rast.html) can create empty grid from the extent of a given spatial object. Here we provide the otters observation (projected in EPSG 2154) as the extent of our grid.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npt_2154 <- project(pt_otter, \"EPSG:2154\")\nres <- 5000 # 5km grid\ngrid <- rast(pt_2154, res = res)\ngrid\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 17, 19, 1  (nrow, ncol, nlyr)\nresolution  : 5000, 5000  (x, y)\nextent      : 723524.6, 818524.6, 6245001, 6330001  (xmin, xmax, ymin, ymax)\ncoord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154) \n```\n\n\n:::\n:::\n\n\n\n\n## Points to grid\n\nThe function [`terra::rasterize()`](https://search.r-project.org/CRAN/refmans/terra/html/rasterize.html) transform vectors to raster. Its argument `fun=count` defines that the values in the cells are the number of points. The argument `background=0` set that the value of the cells with no observation will be 0, instead of NA by default.  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_nobs <- rasterize(pt_2154, grid, fun = \"count\", background = 0)\n\nplot(grid_nobs, main = \"Number of otter observations\")\n```\n\n::: {.cell-output-display}\n![](23_grid_files/figure-html/grid_nobs-1.png){width=672}\n:::\n:::\n\n\n\n\n## Lines to grid   \n\nTo calculate the length of rivers within a grid cell, we use the function [`terra::rasterizeGeom()`](https://search.r-project.org/CRAN/refmans/terra/html/rasterizeGeom.html). Its argument `fun=length` defines that the values in the cells are the length of the rivers.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nriver_2154 <- project(river, \"EPSG:2154\")\n\ngrid_river <- rasterizeGeom(river_2154, grid, fun = \"length\")\nplot(grid_river, main = \"Length of rivers\", plg = list(title = \"(m)\"))\n```\n\n::: {.cell-output-display}\n![](23_grid_files/figure-html/grid_river-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Polygon to grid\n\nTo calculate the percentage of forest in the grid cells, we need first to consider only forest polygons. Then the function [`terra::rasterize()`](https://search.r-project.org/CRAN/refmans/terra/html/rasterize.html) with the option `cover=TRUE` calculates the percentage of forest cover per grid cell.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select only the forest\nforest <- landuse[landuse$nature == \"ForÃªt\"]\n# project the polygons\nforest_2154 <- project(forest, \"EPSG:2154\")\n# rasterize\ngrid_forest <- rasterize(forest_2154, grid, cover = TRUE, background = 0)\n\nplot(grid_forest, main = \"Forest cover\", plg = list(title = \"(%)\"))\n```\n\n::: {.cell-output-display}\n![](23_grid_files/figure-html/grid_forest-1.png){width=672}\n:::\n:::\n\n\n\n\n## Resample raster\n\nFor rasters, we need to transform the original grid to the desired resolution and extent. This operation is done with the function [`terra::resample()`](https://search.r-project.org/CRAN/refmans/terra/html/resample.html). Be careful, this operation degrades the quality of the original raster. Each cell get the weighted average of the neighboring cells.\n\n\n### Elevation\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_alti <- resample(bdalti, grid, method = \"bilinear\")\nplot(grid_alti, main = \"Elevation\", plg = list(title = \"(m)\"))\n```\n\n::: {.cell-output-display}\n![](23_grid_files/figure-html/grid_alti-1.png){width=672}\n:::\n:::\n\n\n\n\n### Temperature\n\nFor CHELSA temperature rasters, we will keep only a summary of 2021: the average temperature over the 12 months of 2021. So we will (1) select only layers that correspond to 2021 (year of the observations) (2) calculate the average, (3) project the raster, and (4) resample to the desired grid.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#1 select the layers corresponding to 2021\nin_2021 <- grep(\"2021\", names(temperature))\nmonthly_temp <- subset(temperature, in_2021)\n#2. calculate the average temperature in 2021\nannual_temp <- mean(monthly_temp, na.rm = TRUE)\n# 3. project to EPSG 2154\ntemp_2154 <- project(annual_temp, \"EPSG:2154\")\n# 4. resample to grid\ngrid_temp <- resample(temp_2154, grid, \"bilinear\")\n\nplot(grid_temp, main = \"Av. temperature\", plg = list(title = \"(K)\"))\n```\n\n::: {.cell-output-display}\n![](23_grid_files/figure-html/grid_temp-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Merge all together\n\nIn `terra`, we can group `SpatRaster` objects into a single one if they all share the same grid. We will then get one grid and multiple layers (also called band) with the different informations.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# merge all information into one single output\nout <- c(grid_nobs, grid_river, grid_forest, grid_alti, grid_temp)\n# we rename the layers to keep information of units\nnames(out) <- c(\"nobs\", \"river_m\", \"forest\", \"elevation_m\", \"temperature_K\")\n\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 17, 19, 5  (nrow, ncol, nlyr)\nresolution  : 5000, 5000  (x, y)\nextent      : 723524.6, 818524.6, 6245001, 6330001  (xmin, xmax, ymin, ymax)\ncoord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154) \nsource(s)   : memory\nnames       : nobs,  river_m,    forest, elevation_m, temperature_K \nmin values  :    0,     0.00, 0.0000000,       0.000,      280.9530 \nmax values  :    7, 56861.96, 0.9665119,    1210.254,      289.1167 \n```\n\n\n:::\n\n```{.r .cell-code}\nplot(out)\n```\n\n::: {.cell-output-display}\n![](23_grid_files/figure-html/merge-1.png){width=672}\n:::\n:::\n\n\n\n\n:::{.callout-note title=\"Your turn\"}\nOur grid includes the Mediterranean Sea, but the otter observations were only made on land. Mask the created raster with the land boundary of France (as in the [Chapter Rasters](https://frbcesab.github.io/spatial-r/chapters/21_rasters.html#mask-the-sea)). \n:::\n\n<details>\n<summary>Click to see the answer</summary>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the border of the country (level = 0)\nfrance_border <- readRDS(here(\"data\", \"gadm41_FRA_0_pk.rds\"))\n# or directly from geodata\n# france_border <- geodata::gadm(\"FRA\", level = 0, path = here(\"data\"))\n# project the coast in Lambert-93\nfrance_2154 <- project(france_border, crs(bdalti))\n# mask (=set to NA) the pixels that are not in the polygon\nout_masked <- mask(out, france_2154)\nplot(out_masked)\n```\n\n::: {.cell-output-display}\n![](23_grid_files/figure-html/mask-1.png){width=672}\n:::\n:::\n\n\n\n\n</details>\n\n## Simple linear model\n\nThe dataset is made of observations gathered without proper sampling schemes, and with potentially many biases. For such data (opportunistic presence-only data), it is recommended to use species occupancy models.  \n\nYet, for our little case study we will do a simple linear model.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# transform the spatial raster data as data.frame\ndf <- data.frame(out_masked)\n\n# make a simple linear model\nm1 <- lm(nobs ~ river_m + forest + elevation_m + temperature_K, data = df)\nsummary(m1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = nobs ~ river_m + forest + elevation_m + temperature_K, \n    data = df)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-0.6221 -0.3503 -0.2522 -0.0324  6.5679 \n\nCoefficients:\n                Estimate Std. Error t value Pr(>|t|)   \n(Intercept)    2.584e+02  8.709e+01   2.967  0.00327 **\nriver_m       -6.591e-08  4.862e-06  -0.014  0.98920   \nforest        -2.689e-01  2.718e-01  -0.989  0.32331   \nelevation_m   -5.833e-03  2.081e-03  -2.803  0.00543 **\ntemperature_K -8.936e-01  3.014e-01  -2.965  0.00329 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.7884 on 276 degrees of freedom\nMultiple R-squared:  0.03659,\tAdjusted R-squared:  0.02262 \nF-statistic:  2.62 on 4 and 276 DF,  p-value: 0.03531\n```\n\n\n:::\n:::\n\n\n\n\nThe linear model is definitely not a good fit to our data (R2 is only 0.03). Moreover, there is strong collinearity between elevation and temperature, and the residuals are not normally distributed (to see how wrong is our model, try `plot(m1)`).   \nIt might help if we use generalized mixed models. For zero-inflated datasets, one option is to make two separate models: (1) model the presence-absence as a `binomial` variable, and (2) model the number of observations with `poisson` distribution. Yet, in our case the main issue here is the high number of 'false' zeros (opportunistic observations, presence-only information) which can only be resolved with species occupancy models (e.g. [`spOccupancy`](https://doi.org/10.1111/2041-210X.13897)). \n\nHowever, it is always recommended to spatially visualize the predictions and the residuals.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set new empty grids\nout_masked$predicted <- rast(grid)\nout_masked$residuals <- rast(grid)\n# add values of prediction and residuals where there is no NA\nout_masked$predicted[!is.na(out_masked$nobs)] <- predict(m1)\nout_masked$residuals[!is.na(out_masked$nobs)] <- residuals(m1)\n# show and compare the observation, prediction and residuals\nplot(out_masked, c(\"nobs\", \"predicted\", \"residuals\"), nc = 3)\n```\n\n::: {.cell-output-display}\n![](23_grid_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "23_grid_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}