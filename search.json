[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spatial-r: Tutorials on spatial data analysis in R",
    "section": "",
    "text": "Introduction\nThis is a collection of tutorials on how to handle spatial data in . The tutorials target students and scientists in ecology with previous knowledge of the R software.\nThe core tutorials were developed for a two half-day workshop, but you can follow the tutorials at your own pace.\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nIn these tutorials, we characterize the habitat of otters that were observed in 2021 around Montpellier, France. This small toy case study is not relevant ecologically but provides a good opportunity to tackle multiple challenges with handling and collecting spatial data.\n\n\n\nWorkshop program\nIntroduction to GIS: vectors vs rasters, coordinate reference system (CRS), and R as a GIS tool\n\nPractice 1 : Vectors (2h)\n\nPoints: Transform otters field observations as spatial points\nLines: Calculate distance from points to nearest lines (river networks)\n\nPolygons: Characterize land cover around sites using spatial polygons\n\n\n\nPractice 2: Rasters (2h)\n\nRaster: Discover what is a raster and get the elevation of field observations\n\nMulti-layer: Trace back past monthly climate at the field sites\nGrid: Transform observations and spatial data into a commun grid\n\n\n\nOther tutorials\n\nToy dataset: Get data from GBIF, IGN and CHELSA and create the toy dataset used in this workshop.\n\n\n\n\n\nR packages\nThe tutorials rely mostly on the -package terra as it was specifically developed to tackle challenges faced by ecologists or agronomists when doing spatial analysis.\n has an exceptional diversity of users and packages, and this is especially true with the dynamic community of -users doing spatial analysis. Another very popular package for handling spatial vector data is sf. The correspondance among terra and sf functions are presented in the vector tutorials.\n\n\nOther resources\nThese tutorials were inspired by very valuable online ressources:\n\nHijman R. Spatial Data Science with R and “terra”\n\nPebesma E. and Bivand R. Spatial Data Science: With Applications in R\nMoraga P. (2023) Spatial Statistics for Data Science: Theory and Practice with R\nLovelace R., Nowosad J., and Muenchow J. (2025) Geocomputation with R\n\nGimond M. (2025) Intro to GIS and Spatial Analysis\n\nSlingsby J. (2025) A minimal introduction to GIS in R\nGiraud, T. et Pecout, H. (2025) Géomatique et cartographie avec R [fr]",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "chapters/01_setup.html",
    "href": "chapters/01_setup.html",
    "title": "Setup",
    "section": "",
    "text": "How to set up R\nThe tutorials rely on , so you need to have it installed on your computer with, ideally, an Integrated Development Environment (IDE) such as RStudio, Visual Studio Code or Positron.\nPlease have a look at the tutorial on how to setup a working environment for scientific computing with : https://frbcesab.github.io/rsetup/",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "chapters/01_setup.html#how-to-set-up-r",
    "href": "chapters/01_setup.html#how-to-set-up-r",
    "title": "Setup",
    "section": "",
    "text": "R packages needed\nWe will use four packages: terra(Hijmans 2025) and sf(Pebesma 2018) for handling spatial data, mapview(Appelhans et al. 2025) for interactive maps, and here(Müller 2025) for locating files locally. Make sure these four packages are installed locally by running the following script:\n\nneeded_packages &lt;- c(\"terra\", \"sf\", \"mapview\", \"here\")\n\ncheck_and_install &lt;- function(x) {\n  if (!requireNamespace(x, quietly = TRUE)) {\n    install.packages(x)\n  }\n}\n\ninvisible(lapply(needed_packages, check_and_install))",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "chapters/01_setup.html#download-toy-dataset",
    "href": "chapters/01_setup.html#download-toy-dataset",
    "title": "Setup",
    "section": "Download toy dataset",
    "text": "Download toy dataset\nAs a toy dataset, the tutorials rely on observed occurrences of otters in 2021 around Montpellier, France. These datasets were downloaded directly from , for more details see the tutorial on creating a toy dataset from GBIF, IGN and CHELSA.\nYou can run the following commands to download the dataset needed for the workshop (total size : 11Mb), or download a zip archive\n\n# set data directory\ndatadir &lt;- here::here(\"data\")\nif (!dir.exists(datadir)) {\n  dir.create(\n    path = datadir,\n    showWarnings = FALSE,\n    recursive = TRUE\n  )\n}\n\n# download base url\nurl_git &lt;- \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data\"\n\n# download GBIF data as csv file (14kb)\nfile1 &lt;- \"gbif_otter_2021_mpl50km.csv\"\ndownload.file(file.path(url_git, file1), file.path(datadir, file1), mode = \"wb\")\n\n# download GBIF data as geopackage file (124kb)\nfile2 &lt;- \"gbif_otter_2021_mpl50km.gpkg\"\ndownload.file(file.path(url_git, file2), file.path(datadir, file2), mode = \"wb\")\n\n# download rivers (2.5Mb)\nfile3 &lt;- \"BDCARTO-River_mpl50km.gpkg\"\ndownload.file(file.path(url_git, file3), file.path(datadir, file3), mode = \"wb\")\n\n# download land cover (4.7Mb)\nfile4 &lt;- \"BDCARTO-LULC_mpl50km\"\nshpext &lt;- c(\"dbf\", \"prj\", \"shp\", \"shx\")\nurl_shp &lt;- file.path(url_git, paste(file4, shpext, sep = \".\"))\ndir_shp &lt;- file.path(datadir, paste(file4, shpext, sep = \".\"))\nfor (i in seq_along(shpext)) {\n  download.file(url_shp[i], dir_shp[i], mode = \"wb\")\n}\n\n# download elevation data (505kb)\nfile5 &lt;- \"BDALTI_mpl50km.tif\"\ndownload.file(file.path(url_git, file5), file.path(datadir, file5), mode = \"wb\")\n\n# download CHELSA monthly temperature (2.2Mb)\nfile6 &lt;- \"CHELSA_monthly_tas_2015_2021.tif\"\ndownload.file(file.path(url_git, file6), file.path(datadir, file6), mode = \"wb\")\n\n# download GADM France country borders  (904 kb)\nfile7 &lt;- \"gadm41_FRA_0_pk.rds\"\ndownload.file(file.path(url_git, file7), file.path(datadir, file7), mode = \"wb\")",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "chapters/01_setup.html#session-information",
    "href": "chapters/01_setup.html#session-information",
    "title": "Setup",
    "section": "Session information",
    "text": "Session information\nFor reproducibility, the tutorials were last compiled on 13 November 2025 with the following libraries:\n\n\nR version 4.5.1 (2025-06-13)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 25.10\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.12.1 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.12.1;  LAPACK version 3.12.0\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] sf_1.0-21      terra_1.8-70   here_1.0.2     mapview_2.11.4\n\nloaded via a namespace (and not attached):\n [1] jsonlite_2.0.0     compiler_4.5.1     Rcpp_1.1.0         dichromat_2.0-0.1 \n [5] leaflet_2.2.3      scales_1.4.0       png_0.1-8          yaml_2.3.10       \n [9] fastmap_1.2.0      lattice_0.22-7     R6_2.6.1           classInt_0.4-11   \n[13] satellite_1.0.6    knitr_1.50         htmlwidgets_1.6.4  units_1.0-0       \n[17] rprojroot_2.1.1    DBI_1.2.3          RColorBrewer_1.1-3 rlang_1.1.6       \n[21] sp_2.2-0           xfun_0.54          cli_3.6.5          magrittr_2.0.4    \n[25] class_7.3-23       crosstalk_1.2.2    digest_0.6.37      grid_4.5.1        \n[29] leafem_0.2.5       base64enc_0.1-3    lifecycle_1.0.4    KernSmooth_2.23-26\n[33] proxy_0.4-27       evaluate_1.0.5     glue_1.8.0         raster_3.6-32     \n[37] farver_2.1.2       codetools_0.2-20   stats4_4.5.1       e1071_1.7-16      \n[41] rmarkdown_2.30     tools_4.5.1        htmltools_0.5.8.1 \n\n\n\n\n\n\nAppelhans, Tim, Florian Detsch, Christoph Reudenbach, and Stefan Woellauer. 2025. Mapview: Interactive Viewing of Spatial Data in r. https://doi.org/10.32614/CRAN.package.mapview.\n\n\nHijmans, Robert J. 2025. Terra: Spatial Data Analysis. https://doi.org/10.32614/CRAN.package.terra.\n\n\nMüller, Kirill. 2025. Here: A Simpler Way to Find Your Files. https://here.r-lib.org/.\n\n\nPebesma, Edzer. 2018. “Simple Features for r: Standardized Support for Spatial Vector Data.” The R Journal 10 (1): 439–46. https://doi.org/10.32614/RJ-2018-009.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "chapters/02_presentation_gis.html",
    "href": "chapters/02_presentation_gis.html",
    "title": "Introduction to GIS",
    "section": "",
    "text": "NoteAn introduction to GIS\n\n\n\n   Source: https://github.com/FRBCesab/spatial-slides   Slides: https://frbcesab.github.io/spatial-slides/intro-GIS",
    "crumbs": [
      "Introduction to GIS"
    ]
  },
  {
    "objectID": "chapters/11_points.html",
    "href": "chapters/11_points.html",
    "title": "Points",
    "section": "",
    "text": "Setup\nIf you haven’t done it already, please follow the setup instructions. Let’s start with loading the required packages.\nsuppressPackageStartupMessages({\n  library(terra)\n  library(mapview)\n  library(here)\n  library(sf)\n})",
    "crumbs": [
      "Vectors",
      "Points"
    ]
  },
  {
    "objectID": "chapters/11_points.html#create-spatial-points-from-data.frame",
    "href": "chapters/11_points.html#create-spatial-points-from-data.frame",
    "title": "Points",
    "section": "Create spatial points from data.frame",
    "text": "Create spatial points from data.frame\nThis is the most common case: you have coordinates from a file (csv or excel) and you want to get spatial information about these locations. The first step is to transform the coordinates as proper spatial object in .\nWe will use a dataset from GBIF with all occurrences of otter recorded in 2021 within a 50km buffer from Montpellier, France. This data was prepared from the tutorial about creating a toy dataset and is stored on Github.\n\nlocalonline\n\n\n\notter &lt;- read.csv(here(\"data\", \"gbif_otter_2021_mpl50km.csv\"))\n\n\n\n\notter &lt;- read.csv(\n  \"https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.csv\"\n)\n\n\n\n\n\ndim(otter)\n\n[1] 83 14\n\nnames(otter)\n\n [1] \"key\"                              \"institutionCode\"                 \n [3] \"species\"                          \"occurrenceStatus\"                \n [5] \"eventDate\"                        \"year\"                            \n [7] \"month\"                            \"day\"                             \n [9] \"decimalLongitude\"                 \"decimalLatitude\"                 \n[11] \"elevation\"                        \"identificationVerificationStatus\"\n[13] \"identifier\"                       \"datasetKey\"                      \n\n\nThe dataset contains 83 observations of otter (in rows), and 14 variables (in column) such as date, coordinates, and data provider. The geographic coordinates are stored in the columns decimalLongitude, and decimalLatitude. They are expressed in decimal degrees, following the WGS84 coordinate reference system (EPSG:4326).\n\n\n\n\n\n\nImportant\n\n\n\nIt is really important to keep track of the projection system of your data. When it is expressed in latitude-longitude and was derived from modern GPS, it is often in WGS84 (EPSG:4326). Problems arise when coordinates are expressed in meters. It can be very complicated to retrieve the projection system if not stored properly with the data.\n\n\nWe have just loaded in R the observations from GBIF, but it is stored in a simple data.frame object,  doesn’t know that it contains spatial information yet. Let’s create a spatial object from the coordinates so that we can easily make a map and see where these observation were made.\n\nterrasf\n\n\nIn terra, the key function for vectors is terra::vect().\n\npt_otter &lt;- vect(\n  otter,\n  geom = c(\"decimalLongitude\", \"decimalLatitude\"),\n  crs = \"EPSG:4326\"\n)\n# summary of the spatial object\npt_otter\n\n class       : SpatVector \n geometry    : points \n dimensions  : 83, 12  (geometries, attributes)\n extent      : 3.28983, 4.46447, 43.30373, 44.06548  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :       key institutionCode     species occurrenceStatus\n type        :     &lt;num&gt;           &lt;chr&gt;       &lt;chr&gt;            &lt;chr&gt;\n values      : 3.059e+09     iNaturalist Lutra lutra          PRESENT\n               3.854e+09    UAR PatriNat Lutra lutra          PRESENT\n               3.854e+09    UAR PatriNat Lutra lutra          PRESENT\n       eventDate  year month   day elevation identificationVerificationStatus\n           &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;                            &lt;chr&gt;\n 2021-01-24T15:~  2021     1    24        NA                               NA\n      2021-01-13  2021     1    13        NA                         Probable\n      2021-01-08  2021     1     8        NA                         Probable\n      identifier      datasetKey\n           &lt;chr&gt;           &lt;chr&gt;\n        68608477 50c9509d-22c7-~\n 5b4c3803-50a9-~ c32f3129-a4dc-~\n cc533347-f1e3-~ c32f3129-a4dc-~\n\n\nAll the information about the terra::SpatVector object can be retrieve individually with the functions terra::ext() for the geographical extent, terra::crs() for the projection system, and dim() for the dimensions (number of objects, and number of variables in the attribute table).\n\n\nIn sf, the key function is sf::st_as_sf().\n\npt_sf &lt;- st_as_sf(\n  otter,\n  coords = c(\"decimalLongitude\", \"decimalLatitude\"),\n  crs = \"EPSG:4326\"\n)\n# summary\npt_sf\n\nSimple feature collection with 83 features and 12 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3.28983 ymin: 43.30373 xmax: 4.46447 ymax: 44.06548\nGeodetic CRS:  WGS 84\nFirst 10 features:\n          key institutionCode     species occurrenceStatus           eventDate\n1  3058935748     iNaturalist Lutra lutra          PRESENT 2021-01-24T15:26:55\n2  3853886594    UAR PatriNat Lutra lutra          PRESENT          2021-01-13\n3  3853886619    UAR PatriNat Lutra lutra          PRESENT          2021-01-08\n4  3853886780    UAR PatriNat Lutra lutra          PRESENT          2021-01-12\n5  4546764953    UAR PatriNat Lutra lutra          PRESENT          2021-01-31\n6  4546968119    UAR PatriNat Lutra lutra          PRESENT          2021-01-17\n7  4547054813    UAR PatriNat Lutra lutra          PRESENT          2021-01-31\n8  4548321676    UAR PatriNat Lutra lutra          PRESENT          2021-01-23\n9  4548484387    UAR PatriNat Lutra lutra          PRESENT          2021-01-31\n10 4552966259    UAR PatriNat Lutra lutra          PRESENT          2021-01-06\n   year month day elevation identificationVerificationStatus\n1  2021     1  24        NA                             &lt;NA&gt;\n2  2021     1  13        NA                         Probable\n3  2021     1   8        NA                         Probable\n4  2021     1  12        NA                         Probable\n5  2021     1  31        NA                         Probable\n6  2021     1  17        NA                         Probable\n7  2021     1  31        NA                         Probable\n8  2021     1  23        NA                         Probable\n9  2021     1  31        NA                         Probable\n10 2021     1   6        NA                         Probable\n                             identifier                           datasetKey\n1                              68608477 50c9509d-22c7-4a22-a47d-8c48425ef4a7\n2  5b4c3803-50a9-465a-a1a7-35c4a4d7d508 c32f3129-a4dc-4e36-86d4-a35cc5cfb04d\n3  cc533347-f1e3-4cf3-9f55-2c7cf60500de c32f3129-a4dc-4e36-86d4-a35cc5cfb04d\n4  3210c6f2-391a-4cc4-b497-b915bbc9d7d4 c32f3129-a4dc-4e36-86d4-a35cc5cfb04d\n5  631348e0-646f-41eb-b3c7-01900054c689 256b9877-cef3-4e8e-84e1-f23299c49655\n6  754868ad-58ef-41eb-b3c7-01900054452d 256b9877-cef3-4e8e-84e1-f23299c49655\n7  771217f4-6470-41eb-b3c7-01900054c695 256b9877-cef3-4e8e-84e1-f23299c49655\n8  b00a76e4-907d-41eb-adf1-041006068357 256b9877-cef3-4e8e-84e1-f23299c49655\n9  b2343db5-646f-41eb-b3c7-01900054c693 256b9877-cef3-4e8e-84e1-f23299c49655\n10 33310104-5041-41eb-bfb5-01900053f23b 256b9877-cef3-4e8e-84e1-f23299c49655\n                    geometry\n1  POINT (3.792841 43.81636)\n2   POINT (3.46399 43.38562)\n3    POINT (3.28983 43.3172)\n4   POINT (3.83235 43.57202)\n5   POINT (3.46399 43.38562)\n6   POINT (3.92099 44.06548)\n7   POINT (3.85823 43.52581)\n8   POINT (3.57398 43.63949)\n9    POINT (3.28983 43.3172)\n10  POINT (3.54517 43.75695)\n\n\nAll the information about the sf object can be retrieve individually with the functions sf::st_bbox() for the geographical extent, sf::st_crs() for the projection system, and dim() for the dimensions (number of objects, and number of variables in the attribute table).",
    "crumbs": [
      "Vectors",
      "Points"
    ]
  },
  {
    "objectID": "chapters/11_points.html#map-the-observations",
    "href": "chapters/11_points.html#map-the-observations",
    "title": "Points",
    "section": "Map the observations",
    "text": "Map the observations\nOnce the data is formatted as spatial vector, it can be visualized as static map with the function plot() or interactively with the package mapview.\n\nmapviewterrasf\n\n\nThe function mapview::mapview() creates easily interactive map. If you want to fine tune your map, have a look at this tutorial. The function mapview::mapview() works well with objects loaded from terra or sf.\n\nmapview(pt_otter) # mapview(pt_sf) works fine as well\n\n\n\n\n\n\n\nThe function plot() .\n\nplot(pt_otter)\n\n\n\n\n\n\n\n\n\n\nIn sf, the function plot() visualize the attributes of the vectors by default. If you want a simple map with only the geometry, use st_geometry().\n\nplot(st_geometry(pt_sf), axes = TRUE)",
    "crumbs": [
      "Vectors",
      "Points"
    ]
  },
  {
    "objectID": "chapters/11_points.html#add-new-attribute",
    "href": "chapters/11_points.html#add-new-attribute",
    "title": "Points",
    "section": "Add new attribute",
    "text": "Add new attribute\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nCan we see a temporal pattern in the locations of the otter observations?\n\n\nLet’s transform the date of the observation as the Julian date. Then we will add this new variable to the attribute table of our spatial object in order to map it.\nThe date formatting in R is powerful but hard to grasp. Make sure to have a look at the documentations of as.Date() and strptime() if you want more details.\n\n# transform the date as Julian day\njulian &lt;- as.Date(pt_otter$eventDate) |&gt; format(\"%j\") |&gt; as.numeric()\n\nNow we can attach the Julian day in the spatial object. The attribute table can be accessed as a normal data.frame, and we can create a new column with $.\n\nterrasf\n\n\n\npt_otter$julian &lt;- julian\n\n\n\n\npt_sf$julian &lt;- julian\n\n\n\n\n\ninteractiveterrasf\n\n\nTo map an attribute in mapview::mapview(), add the parameter zcol with the variable of interest.\n\nmapview(pt_otter, zcol = \"julian\", layer.name = \"Julian date\")\n\n\n\n\n\n\n\n\nplot(pt_otter, \"julian\", type = \"continuous\", main = \"Julian date\")\n\n\n\n\n\n\n\n\n\n\n\nplot(pt_sf[\"julian\"], axes = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\nVisually check if there is a bias in the spatial distributions of observations due to data provider (information in the column institutionCode).\n\n\n\n\nClick to see the answer\n\n\n# with mapview\nmapview(pt_sf, zcol = \"institutionCode\")\n# or in terra\nplot(pt_otter, \"institutionCode\")\n# or in sf\nplot(pt_sf[\"institutionCode\"], axes = TRUE)",
    "crumbs": [
      "Vectors",
      "Points"
    ]
  },
  {
    "objectID": "chapters/11_points.html#export-data",
    "href": "chapters/11_points.html#export-data",
    "title": "Points",
    "section": "Export data",
    "text": "Export data\nFor vectors, it is recommended to export them as geopackage file (extension .gpkg). Compare to traditional ESRI shapefile, the geopackage format stores the data in a single file and the column names are preserved.\n\nterrasf\n\n\nIn terra, the function to export a spatial vector is terra::writeVector().\n\nwriteVector(pt_otter, here(\"data\", \"gbif_otter_2021_mpl.gpkg\"))\n\n\n\n\n\n\n\nWarning\n\n\n\nIf you want to overwrite an existing file, use the argument overwrite = TRUE.\n\n\n\n\nIn sf, the function to export a spatial vector is sf::st_write().\n\nst_write(pt_sf, here(\"data\", \"gbif_otter_2021_mpl.gpkg\"))\n\n\n\n\n\n\n\nWarning\n\n\n\nIf you want to overwrite an existing file, use the argument append = FALSE.",
    "crumbs": [
      "Vectors",
      "Points"
    ]
  },
  {
    "objectID": "chapters/11_points.html#conversion-between-sf-and-terra",
    "href": "chapters/11_points.html#conversion-between-sf-and-terra",
    "title": "Points",
    "section": "Conversion between sf and terra",
    "text": "Conversion between sf and terra\nIt is confusing to have two dominant packages terra and sf with similar functionalities. Luckily, the conversion between the two data formats is easy.\n\nfrom terra to sffrom sf to terra\n\n\nTo convert a terra SpatVector vector into a sf simple feature, the function is sf::st_as_sf().\n\npt_sf &lt;- st_as_sf(pt_otter)\n\n\n\nTo convert a sf simple feature into terra SpatVector, the function is terra::vect().\n\npt_terra &lt;- vect(pt_sf)\n\n\n\n\n\n\n\nWarning\n\n\n\nNon-homogeneous features (GEOMETRYCOLLECTION) can’t be converted in terra as a SpatVector object. In this case, you must homogenize the type of features, and transform them into an accepted format (points, lines or polygons). Check out the functions sf::st_cast() and sf::st_collection_extract() that can help with the transformation.",
    "crumbs": [
      "Vectors",
      "Points"
    ]
  },
  {
    "objectID": "chapters/12_lines.html",
    "href": "chapters/12_lines.html",
    "title": "Lines",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "Vectors",
      "Lines"
    ]
  },
  {
    "objectID": "chapters/12_lines.html#setup",
    "href": "chapters/12_lines.html#setup",
    "title": "Lines",
    "section": "",
    "text": "Follow the setup instructions if you haven’t followed the tutorial on points\n\nIf haven’t done it already, please follow the setup instructions. Let’s start with loading the required packages.\n\nsuppressPackageStartupMessages({\n  library(mapview)\n  library(here)\n  library(sf)\n  library(terra)\n})\n\n\nlocalonline\n\n\n\npt_otter &lt;- vect(here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\n\n\n\n\npt_otter &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.gpkg\"\n)",
    "crumbs": [
      "Vectors",
      "Lines"
    ]
  },
  {
    "objectID": "chapters/12_lines.html#load-lines-from-a-geopackage-file",
    "href": "chapters/12_lines.html#load-lines-from-a-geopackage-file",
    "title": "Lines",
    "section": "Load lines from a geopackage file",
    "text": "Load lines from a geopackage file\nLines are made of multiple points. It is possible to create lines directly from coordinates but, in practice, it often comes from an existing spatial dataset. In our example, we will load rivers for the area of interest from IGN data BD CARTO.\nNote that this dataset has rough resolution (BD TOPO would be recommended for real analysis), but it’s perfect for our illustration and learning purpose.\n\nterrasfonline\n\n\nYou can load vector data with the function terra::vect().\n\nriver &lt;- vect(here(\"data\", \"BDCARTO-River_mpl50km.gpkg\"))\n\n\n\nIn sf, there are two functions to read vector data sf::st_read() and sf::read_sf(). The main difference lies in the format of the attribute table: it is stored as data.frame with st_read, and as a tibble with read_sf().\n\nriver_sf &lt;- st_read(here(\"data\", \"BDCARTO-River_mpl50km.gpkg\"))\n\nReading layer `BDCARTO-River_mpl50km' from data source \n  `/home/romain/GitHub/spatial-r/data/BDCARTO-River_mpl50km.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2110 features and 8 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 3.18983 ymin: 43.21278 xmax: 4.56447 ymax: 44.16754\nGeodetic CRS:  WGS 84\n\n\n\n\nIf you don’t have the data locally (and won’t use it repeatedly), you can load it directly with:\n\nriver &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-River_mpl50km.gpkg\"\n)\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nHow many different stretches of river was loaded?\nWhat is the coordinate reference system (CRS) of the loaded river data?\nCan you get the name of the all the river stretches?\n\n\n\n\n\nClick to see the answer\n\n\nThere are 2110 stretches (=lines) in the dataset. You can access it with dim(river), nrow(river) or just by typing river in the console.\n\nThe coordinates are in WGS 84 (EPSG 4326). You can access this information with crs(river, describe = TRUE) (or in sf with st_crs(river_sf)).\nThe column that stored the name of river stretches is toponyme. You could identify it with head(river) or names(river). There are 151 river stretches without names (table(is.na(river$toponyme))).",
    "crumbs": [
      "Vectors",
      "Lines"
    ]
  },
  {
    "objectID": "chapters/12_lines.html#calculate-length-of-lines",
    "href": "chapters/12_lines.html#calculate-length-of-lines",
    "title": "Lines",
    "section": "Calculate length of lines",
    "text": "Calculate length of lines\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nCan we see whether otters were observed close to small or large rivers? We will approximate the rivers’ size by their length.\n\n\nWhen calculating distances and length, be careful with projection systems. Some are not suited to calculate distance, prefer equidistance projections or use local projection systems. Recent implementation of terra and sf calculates spherical distances when using geographic coordinates (in longitude and latitude) which is the most accurate and recommended to account for Earth’s curvature.\n\nterrasf\n\n\nThe function terra::perim() returns the length of lines in meters.\n\n# calculate the length of rivers (in km)\nriver$length_km &lt;- perim(river) / 1000\n\n\n\nThe function sf::st_length() calculate the length of lines.\n\n# calculate the length of rivers (in km)\nriver_sf$length_km &lt;- st_length(river_sf) / 1000\n\n\n\n\n\n# see the distribution of river length\nboxplot(river$length_km, ylab = \"length (km)\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nWhich is the longest river in our dataset?\n\n\n\n\n\n\nClick to see the answer\n\n\n# get the name of the longest river\nriver$toponyme[which.max(river$length_km)]\n\n[1] \"l'Hérault\"",
    "crumbs": [
      "Vectors",
      "Lines"
    ]
  },
  {
    "objectID": "chapters/12_lines.html#map-multiple-layers",
    "href": "chapters/12_lines.html#map-multiple-layers",
    "title": "Lines",
    "section": "Map multiple layers",
    "text": "Map multiple layers\nLet’s map the river and their length, as well as position of the otters observations.\n\ninteractiveterrasf\n\n\nYou can combine multiple layers in mapview with a +.\n\nmapview(river, zcol = \"length_km\") +\n  mapview(pt_otter, col.regions = \"red\", color = NA)\n\n\n\n\n\n\n\nIn terra, use the argument add=TRUE or the function terra::points() to add points to an existing map.\n\nplot(\n  river,\n  y = \"length_km\",\n  type = \"continuous\",\n  main = \"River length\", # title of the map\n  plg = list(title = \"(km)\") # add legend title\n)\nplot(pt_otter, add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIf you want to overlay multiple spatial object with base plot from sf, don’t forget to use the argument reset=FALSE in the first plot().\n\n\n\nplot(river_sf[\"length_km\"], reset = FALSE, axes = TRUE)\nplot(pt_otter, add = TRUE)",
    "crumbs": [
      "Vectors",
      "Lines"
    ]
  },
  {
    "objectID": "chapters/12_lines.html#calculate-distance-to-the-nearest-line",
    "href": "chapters/12_lines.html#calculate-distance-to-the-nearest-line",
    "title": "Lines",
    "section": "Calculate distance to the nearest line",
    "text": "Calculate distance to the nearest line\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nAt which distance from a river were the otters observed?\n\n\nTo calculate distance among objects, we use the function terra::distance().\nBefore comparing two spatial objects, it is recommended to plot them (as in the previous figure) and make sure their projection systems are the same and the extents match. Do not use the package mapview because it will automatically project the datasets.\n\n# make sure the spatial objects have the same projection\ncrs(river) == crs(pt_otter)\n\n[1] TRUE\n\n\n\nterrasf\n\n\n\n# calculate the distance between all points and lines\ndistance_matrix &lt;- distance(pt_otter, river)\n# get which river is the closest\nnearest_river &lt;- apply(distance_matrix, 1, which.min)\n# get the nearest distance\nnearest_distance &lt;- apply(distance_matrix, 1, min)\n\n\n\n\n\n\n\nWarning\n\n\n\nBe aware that the newly added function terra::nearest() is not as precise as the approach shown above (as in terra 1.8-70, 03/11/2025).\n\n\n\n\nIn sf, the same procedure as in terra can be followed with sf::st_distance(). However it is much faster to use a two-step process: (1) find the closest river with sf::st_nearest_feature() and (2) calculate the distance between points and their closest river with sf::st_distance().\n\n# Step 1: Find index of nearest line for each point\nnearest_river_sf &lt;- st_nearest_feature(st_as_sf(pt_otter), river_sf)\n\nThe object nearest_river_sf is a vector containing the index of the closest river for each observation.\n\n# Step 2: Calculate distance only to the nearest line\nnearest_distance_sf &lt;- st_distance(\n  st_as_sf(pt_otter),\n  river_sf[nearest_river_sf, ],\n  by_element = TRUE\n)\n\n\n\n\n\nboxplot(nearest_distance, ylab = \"distance to river (m)\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nWhich are the rivers with most sights of otters?\n\nMake a map with the distance to river and visually check the coherence of the calculation.\n\n(Reflexion) What can be the factors explaining the few outliers with large distances (&gt;1km)?\n\n\n\n\n\nClick to see the answer 1\n\n\ntable(river$toponyme[nearest_river]) |&gt;\n  sort(decreasing = TRUE) |&gt;\n  head(5)\n\n\n                                                         l'Hérault \n                                                                 8 \n                                                            la Vis \n                                                                 8 \n                                                        le Lamalou \n                                                                 4 \nCanal d'Irrigation du Bas Rhône-Languedoc ou Canal Philippe Lamour \n                                                                 3 \n                                      Canal de Peccais à Sylvéréal \n                                                                 3 \n\n\n\n\n\nClick to see the answer 2\n\n\n# add the distance to river to the spatial object\npt_otter$dist_river &lt;- nearest_distance\n\n# make an interactive map which is best to check the calculation\nmapview(river) +\n  mapview(pt_otter, z = \"dist_river\")",
    "crumbs": [
      "Vectors",
      "Lines"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html",
    "href": "chapters/13_polygons.html",
    "title": "Polygons",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#setup",
    "href": "chapters/13_polygons.html#setup",
    "title": "Polygons",
    "section": "",
    "text": "Follow the setup instructions if you haven’t followed the tutorial on points\n\nIf haven’t done it already, please follow the setup instructions. Let’s start with loading the required packages.\n\nsuppressPackageStartupMessages({\n  library(mapview)\n  library(here)\n  library(sf)\n  library(terra)\n})\n\n\nlocalonline\n\n\n\npt_otter &lt;- vect(here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\n\n\n\n\npt_otter &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.gpkg\"\n)",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#load-polygons-from-a-shapefile",
    "href": "chapters/13_polygons.html#load-polygons-from-a-shapefile",
    "title": "Polygons",
    "section": "Load polygons from a shapefile",
    "text": "Load polygons from a shapefile\nIn this example, we will load land cover information for the area of interest from IGN data BD CARTO.\nNote that this dataset has rough resolution (OSO or Corine land cover would be more suited for real analysis), but it’s perfect for our illustration and learning purposes.\n\nterrasfonline\n\n\nYou can load vector data with the function terra::vect().\n\nlanduse &lt;- vect(here(\"data\", \"BDCARTO-LULC_mpl50km.shp\"))\n\n\n\n\nlanduse_sf &lt;- st_read(here(\"data\", \"BDCARTO-LULC_mpl50km.shp\"))\n\nReading layer `BDCARTO-LULC_mpl50km' from data source \n  `/home/romain/GitHub/spatial-r/data/BDCARTO-LULC_mpl50km.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 2910 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 3.18983 ymin: 43.20373 xmax: 4.56447 ymax: 44.16754\nGeodetic CRS:  WGS 84\n\n\n\n\nIf you don’t have the data locally (and won’t use it repeatedly), you can load it directly with:\n\nlanduse &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-LULC_mpl50km.shp\"\n)\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nHow many different polygons are used in the land cover of our study area?\nWhat is the coordinate reference system (CRS) of the loaded river data?\nHow many land cover classes are there? Which class has the most polygons?\n\n\n\n\n\nClick to see the answer\n\n\nThere was 2910 polygons in the dataset. You can access it with dim(landuse), nrow(landuse) or just by typing landuse in the console.\n\nThe coordinates are in WGS 84 (EPSG 4326). You can access this information with crs(landuse, describe = TRUE) (or in sf with st_crs(landuse_sf)).\nThe column that stored the cover classes is nature. You could identify it with head(landuse) or names(landuse). There are 12 land cover classes, Prairie is the class with most polygons (table(landuse$nature)).",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#visualization",
    "href": "chapters/13_polygons.html#visualization",
    "title": "Polygons",
    "section": "Visualization",
    "text": "Visualization\nBefore comparing two spatial objects (the otters observations and the land cover), it is recommended to plot them and make sure their projection systems are the same and the extents match.\nDo not use the package mapview because it will automatically project the datasets.\n\nterrasf\n\n\n\nplot(landuse, y = \"nature\", border = NA)\nplot(pt_otter, add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\nplot(landuse_sf[\"nature\"], reset = FALSE, border = FALSE, axes = TRUE)\nplot(pt_otter, add = TRUE, pch = 16)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWhen you want to overlay multiple spatial object with base plot from sf, don’t forget to use the argument reset=FALSE.",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#calculate-area",
    "href": "chapters/13_polygons.html#calculate-area",
    "title": "Polygons",
    "section": "Calculate area",
    "text": "Calculate area\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nWhat is the dominant land cover in our study area?\n\n\nThe function terra::expanse() calculates the area in \\(m^2\\). When calculating areas, be careful with projection systems. Some are not suited to calculate areas. Prefer equal-area projections or use local projection systems (if your study area is small).\nLuckily, the package terra calculates by default the geodesic area (based on lat/long coordinates and considering Earth’s curvature) which is the most accurate estimate and avoid errors due to wrongly used projection system.\n\nterrasf\n\n\n\n# calculate the area in ha\narea_polygons &lt;- expanse(landuse) * 0.0001\n# store the area as atribute\nlanduse$area_ha &lt;- as.numeric(area_polygons)\n\n\n\nIn sf, it is recommended to project the dataset to a equal area projection, such as the Lambert azimuthal equal-area for Europe EPSG:3035.\n\n# project land cover to an equal-area projection system\nlanduse_3035 &lt;- st_transform(landuse_sf, crs = 3035)\n# calculate area of polygons (in hectare)\narea_polygons &lt;- st_area(landuse_3035) * 0.0001\n# store as attribute in landuse\nlanduse_3035$area_ha &lt;- as.numeric(area_polygons)\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nWhich are the largest land cover classes in our study area? Why?\n\n\n\n\n\nClick to see the answer\n\n\n# see area per land use classes\narea_landuse &lt;- tapply(landuse$area_ha, landuse$nature, sum)\nsort(area_landuse)\n\n   Rocher, éboulis Carrière, décharge     Sable, gravier      Marais salant \n          37.78454         1916.22618         2353.14638         3455.79520 \n  Zone d'activités  Marais, tourbière               Bâti       Broussailles \n       15224.16350        29467.47117        55654.39730        97923.34835 \n     Vigne, verger            Prairie          Eau libre              Forêt \n      206514.68518       206833.73332       272561.76875       278134.18692 \n\n\nThe categories Forêt (=forest) and Eau libre (=running water) are the largest land covers. As it can be seen in the previous map, large part of the Mediterranean Sea is included in the land cover data.",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#mask-the-sea",
    "href": "chapters/13_polygons.html#mask-the-sea",
    "title": "Polygons",
    "section": "Mask the sea",
    "text": "Mask the sea\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nOur study area was defined as a square buffer around Montpellier. This area include the Mediterranean Sea. It is recommended to mask the sea in order to consider only areas where otters could have been potentially spotted.\n\n\nThere are two approaches to mask an area: (1) identify which area to remove from the data itself, or (2) use a mask from another data source (this approach will be shown when dealing with rasters). In this case, it is easier and more accurate to detect directly from the data which polygons to remove. In fact, the largest polygon corresponds to the Mediterranean Sea. So we just need to remove it.\n\n# the largest polygon correspond to the mediterranean\nlanduse$nature[which.max(landuse$area_ha)]\n\n[1] \"Eau libre\"\n\n# remove the largest polygon\nlanduse_nomed &lt;- landuse[-which.max(landuse$area_ha), ]\n# visually verify the output\nplot(landuse_nomed, y = \"nature\", border = NA)\n\n\n\n\n\n\n\n\nThen we can recalculate the percentage of land cover per class.\n\ncover_ha &lt;- tapply(landuse_nomed$area_ha, landuse_nomed$nature, sum)\n# percentage of land cover classes in the terrestrial study area\ncover_perc &lt;- cover_ha / sum(cover_ha) * 100\n#show rounded values\nround(cover_perc, 2)\n\n              Bâti       Broussailles Carrière, décharge          Eau libre \n              5.98              10.52               0.21               3.61 \n             Forêt      Marais salant  Marais, tourbière            Prairie \n             29.87               0.37               3.16              22.21 \n   Rocher, éboulis     Sable, gravier      Vigne, verger   Zone d'activités \n              0.00               0.25              22.18               1.64",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#polygons-to-points",
    "href": "chapters/13_polygons.html#polygons-to-points",
    "title": "Polygons",
    "section": "Polygons to points",
    "text": "Polygons to points\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nWhat is the land cover class at the location of the otters observations?\n\n\n\nterrasf\n\n\nWe can extract the land cover class of the points with terra::extract():\n\npt_landcover &lt;- extract(landuse, pt_otter)\n\n\n\nWe can extract the land cover class of the points with sf::st_join():\n\npt_landcover &lt;- st_join(st_as_sf(pt_otter), landuse_sf)\n\n\n\n\n\n# see the number of observations per land use classes\ntable(pt_landcover$nature)\n\n\n             Bâti      Broussailles         Eau libre             Forêt \n                8                17                 1                29 \nMarais, tourbière           Prairie     Vigne, verger \n                3                16                 9 \n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\n[stat] Which classes are over- or under- represented compare to the distribution of classes over the whole study area?\n\n\n\n\n\nClick to see the answer\n\n\n# calculate the percentage of otters observations per class\ncover_obs_perc &lt;- table(pt_landcover$nature) / nrow(pt_landcover) * 100\n# match all classes with the one from the observations\nm0 &lt;- match(names(cover_perc), names(cover_obs_perc))\n# create a data.frame\ncover &lt;- data.frame(\n  class = names(cover_perc),\n  all = as.numeric(cover_perc),\n  obs = as.numeric(cover_obs_perc[m0])\n)\n# non matchin elements = 0%\ncover[is.na(cover)] &lt;- 0\n# calculate the difference between observed and expected\ncover$delta &lt;- cover$obs - cover$all\n# add left margin to the plot\npar(mar = c(4, 8, 4, 1))\nbarplot(\n  cover$delta,\n  horiz = TRUE,\n  names = cover$class,\n  las = 1,\n  xlab = \"Difference between observed and expected cover (%)\"\n)",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#polygons-to-polygons",
    "href": "chapters/13_polygons.html#polygons-to-polygons",
    "title": "Polygons",
    "section": "Polygons to polygons",
    "text": "Polygons to polygons\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nWhat is the land cover distribution around the locations of the otters observations?\n\n\nTo characterize the area surrounding the observations, we need to (!) create buffers, (2) calculate the intersection among the buffers and the land cover, and (3) calculate the area of the land cover classes intersecting the buffers.\n\nCreate buffer\n\nterrasf\n\n\nWe can create buffer with terra::buffer(). In our example, we will create buffers of 1km.\n\ndist_buffer &lt;- 1000 # buffer of 1000 m\npoly_otter &lt;- buffer(pt_otter, dist_buffer)\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nsf uses s2 when the coordinates are geographic (e.g. EPSG:4326) which creates buffers with low quality (in sf 1.0-21, tested on 03/11/2025).\nIt is recommended to use projected coordinates when using the function sf::st_buffer().\n\n\n\ndist_buffer &lt;- 1000 # buffer of 1000 m\n# transform to an equal-area projection system: better for area\npt_otter_3035 &lt;- st_as_sf(pt_otter) |&gt; st_transform(3035)\npoly_otter_3035 &lt;- st_buffer(pt_otter_3035, dist_buffer)\n\n\n\n\n\n\nVisualize buffer\nFor illustration, we only show the buffer around the first observation.\nThe parameter ext limit the map to the extent of the given spatial object.\n\n# plot the land cover limited to the extent of the buffer\nplot(landuse, y = \"nature\", ext = poly_otter[1])\n# add the buffer as a line of width 2\nplot(poly_otter[1], lwd = 2, add = TRUE)\n# add the observation as a red dot\nplot(pt_otter[1], col = \"red\", add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nWhat are the areas of the newly created buffers?\n\n\n\n\n\nClick to see the answer\n\n\n# calculate the area of the buffers\nbuffer_area &lt;- expanse(poly_otter)\n# see the distribution of the buffer areas\nsummary(buffer_area)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n3128689 3128689 3128689 3128689 3128689 3128689 \n\n# distribution of the buffer areas from sf\nsummary(st_area(poly_otter_3035))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n3140157 3140157 3140157 3140157 3140157 3140157 \n\n\nThe difference with expected value of \\(3141593\\) is due to the way buffers are defined (by default, in 40 points in terra and 120 points in sf). If you want more precise buffers, you can change the parameter quadsegs from the terra::buffer() function. The roundness of the buffers is not important for most cases. It is much more important that all buffers have the same area.\n\n\n\nIntersection among polygons\nWe can now intersect the buffers with the land cover information with the function terra::intersect().\n\nterrasf\n\n\n\nbuffer_landcover &lt;- intersect(landuse, poly_otter)\n\n# visualize the intersection\n# not plotted here to lighten the webpage\n# mapview(buffer_landcover, z = \"nature\")\n\n# show a zoom on the land cover of the first buffer\nplot(\n  buffer_landcover[buffer_landcover$key %in% poly_otter$key[1]],\n  y = \"nature\"\n)\n\n\n\n\n\n\n\n\n\n\n\nbuffer_landcover_sf &lt;- st_intersection(poly_otter_3035, landuse_3035)\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\n# visualize the intersection (not plotted to lighten the webpage)\n# mapview(buffer_landcover, z = \"nature\")\n\n\n\n\n\n\nLand cover area per buffer\nWe need to update the area of the land cover intersecting the buffers.\n\n# Calculate area for each polygon\nbuffer_landcover$area_ha &lt;- expanse(buffer_landcover) * 0.0001\n\n# Calculate area per buffer and nature class\nclass_area &lt;- tapply(\n  buffer_landcover$area_ha,\n  list(buffer_landcover$key, buffer_landcover$nature),\n  sum\n)\n#replace NA by 0\nclass_area[is.na(class_area)] &lt;- 0\n# calculate the area of the buffer\nsum_area &lt;- rowSums(class_area)\n# calculate the percentage per class\nperc_class &lt;- class_area / sum_area * 100\n\n# add margin at the bottom\npar(mar = c(7, 4, 1, 1))\nbarplot(apply(perc_class, 2, mean), las = 2, ylab = \"Percentage land cover\")",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html",
    "href": "chapters/21_rasters.html",
    "title": "Rasters",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#setup",
    "href": "chapters/21_rasters.html#setup",
    "title": "Rasters",
    "section": "",
    "text": "Follow the setup instructions if you haven’t followed the previous tutorials\n\nIf haven’t done it already, please follow the setup instructions.\nLet’s start with loading the required packages.\n\nsuppressPackageStartupMessages({\n  library(mapview)\n  library(here)\n  library(terra)\n})\n\nLoad the observations of otters recorded in 2021 within a 50km buffer from Montpellier, France.\n\nlocalonline\n\n\n\npt_otter &lt;- vect(here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\n\n\n\n\nurl_github &lt;- \"https://github.com/FRBCesab/spatial-r/raw/main/data/\"\npt_otter &lt;- vect(paste0(url_github, \"gbif_otter_2021_mpl50km.gpkg\"))",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#load-raster-from-a-geotiff-file",
    "href": "chapters/21_rasters.html#load-raster-from-a-geotiff-file",
    "title": "Rasters",
    "section": "Load raster from a geotiff file",
    "text": "Load raster from a geotiff file\nWe will use the elevation data from IGN data BD ALTI which was aggregated at 250m resolution (instead of its original resolution of 25m). Note that the rough resolution of this dataset is perfect for our learning purpose. Yet for real analyses, you might consider finer spatial data. The function to read raster file is terra::rast()\n\nlocalonline\n\n\n\nbdalti &lt;- rast(here(\"data\", \"BDALTI_mpl50km.tif\"))\n\n\n\nIf you don’t have the data locally (and won’t use it repeatedly), you can load it directly with:\n\nbdalti &lt;- rast(\n  \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDALTI_mpl50km.tif\"\n)",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#rasters-characteristics",
    "href": "chapters/21_rasters.html#rasters-characteristics",
    "title": "Rasters",
    "section": "Rasters characteristics",
    "text": "Rasters characteristics\n\nbdalti\n\nclass       : SpatRaster \nsize        : 432, 439, 1  (nrow, ncol, nlyr)\nresolution  : 250, 250  (x, y)\nextent      : 715438.3, 825188.3, 6233959, 6341959  (xmin, xmax, ymin, ymax)\ncoord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154) \nsource      : BDALTI_mpl50km.tif \nname        : BDALTI_mpl50km \n\n\nThe loaded raster is projected in RGF93 v1 / Lambert-93 (EPSG 2154). It is a matrix with 432 rows, 439 columns, and a spatial resolution of 250m (on x and y). All the information about terra::SpatRaster can be accessed individually. Use terra::crs() for information on the projection system, terra::ext() for the geographical extent, terra::res() for the resolution, and dim() for the dimensions (number of rows, number of columns and number of layers).\n\n# get the name of the layer\nnames(bdalti)\n\n[1] \"BDALTI_mpl50km\"\n\n# rename the layer (for simplicity)\nnames(bdalti) &lt;- \"elevation\"\n\nWe can access all values of the raster with the function terra::values(). This operation is often not needed and not recommended if you have large rasters. But it is the only way to get the distribution of all values.\n\n# get all the values : values()\n# use only for small raster\n# else it takes large amount of time and memory\nboxplot(values(bdalti), ylab = \"elevation (m)\")\n\n\n\n\n\n\n\n# mean elevation in our study area\nsummary(values(bdalti))\n\n   elevation        \n Min.   :  -0.9723  \n 1st Qu.:   1.4320  \n Median :  84.2625  \n Mean   : 198.9497  \n 3rd Qu.: 258.9347  \n Max.   :1536.2190",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#visualization",
    "href": "chapters/21_rasters.html#visualization",
    "title": "Rasters",
    "section": "Visualization",
    "text": "Visualization\nSimilar to vectors, rasters can be visualized as static map with the function plot() or interactively with the package mapview.\n\nstaticinteractive\n\n\n\nplot(bdalti)\n\n\n\n\n\n\n\n\n\n\n\nmapview(bdalti)",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#mask-the-sea",
    "href": "chapters/21_rasters.html#mask-the-sea",
    "title": "Rasters",
    "section": "Mask the sea",
    "text": "Mask the sea\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nOur study area was defined as a square buffer around Montpellier. This area include the Mediterranean Sea. It is recommended to mask the sea in order to consider only areas where otters could have been potentially spotted.\n\n\nTo mask all pixels that don’t fit our study area (the terrestrial environment 50km around Montpellier), we need (1) to get the borders of France from GADM, (2) project the border to match the elevation raster, and (3) mask the area that are not in the country polygon with the function terra::mask().\n\nlocalgeodata\n\n\n\n# get the border of the country\nfrance_border &lt;- readRDS(here(\"data\", \"gadm41_FRA_0_pk.rds\"))\n\n\n\n\n# get the border of the country (level = 0)\nfrance_border &lt;- geodata::gadm(\"FRA\", level = 0, path = here(\"data\"))\n\n\n\n\n\n# project the coast in Lambert-93\nfrance_2154 &lt;- project(france_border, crs(bdalti))\n\n# mask (=set to NA) the pixels that are not in the polygon\nalti_masked &lt;- mask(bdalti, france_2154)\n\n# visualize the new raster without the Mediterranean Sea\nplot(alti_masked)\n\n\n\n\n\n\n\n# mean elevation in our study area (excluding sea)\nsummary(values(alti_masked), na.rm = TRUE)\n\n   elevation       \n Min.   :  -0.972  \n 1st Qu.:  45.448  \n Median : 138.845  \n Mean   : 252.695  \n 3rd Qu.: 339.775  \n Max.   :1536.219  \n NA's   :40336",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#raster-to-points",
    "href": "chapters/21_rasters.html#raster-to-points",
    "title": "Rasters",
    "section": "Raster to points",
    "text": "Raster to points\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nNow that we have loaded the elevation data, let’s get the elevation at the location of otters observations.\n\n\n\nChecking projections and extent\nRemember that before comparing two spatial objects, it is always a good idea to map them together.\n\nplot(alti_masked)\nplot(pt_otter, add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\nWhy can’t you see the otters observations? How to fix this problem?\n\n\n\n\nClick to see the answer\n\nIndeed, the spatial points with the otters observations don’t share the same projection than the elevation raster. We need to project the spatial points to the CRS of the elevation data.\n\n\n\n\n\n\nImportant\n\n\n\nIt is not recommended to project raster objects. When you have the choice, it is always better to project vector data to the CRS of the raster.\n\n\n\n# the projection systems are not matching\ncrs(bdalti) == crs(pt_otter)\n\n[1] FALSE\n\n# let's project the otter observations to the raster's CRS\npt_2154 &lt;- project(pt_otter, crs(bdalti))\n\n# now we can check that the points overlay the elevation data\nplot(alti_masked)\nplot(pt_2154, col = \"red\", add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\nExtraction of elevation values\nNow we can use the function terra::extract() to get the elevation of the observations.\n\npt_alti &lt;- extract(alti_masked, pt_2154)\n\n# visualize the extracted values\nboxplot(pt_alti$elevation, ylab = \"elevation (m)\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nCompare the extracted elevation with the elevation provided with GBIF (in the attribute table of the points).\nAre otters changing their elevation distribution depending on the time of the year? In other words, can we see differences in elevation depending on the time of the year in which the observations were made?\n\n\n\n\n\nClick to see the answer 1\n\n\n# check with recorded\nplot(\n  pt_alti$elevation,\n  pt_otter$elevation,\n  xlab = \"elevation (m) GBIF values\",\n  ylab = \"elevation (m) BDALTI values\",\n  asp = 1\n)\n# add identity line\nabline(a = 0, b = 1)\n\n\n\n\n\n\n\n\n\n\n\nClick to see the answer 2\n\n\nboxplot(\n  pt_alti$elevation ~ pt_otter$month,\n  xlab = \"Month of observation\",\n  ylab = \"elevation (m)\"\n)",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#raster-to-polygons",
    "href": "chapters/21_rasters.html#raster-to-polygons",
    "title": "Rasters",
    "section": "Raster to polygons",
    "text": "Raster to polygons\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nWhat is the elevation around the locations of the otters observations?\n\n\n\nCreate buffer\nWe can create buffer with terra::buffer(). It is recommended to work on geographic coordinates (latitude/longitude), or in an equal-area projection (which is not the case of Lambert-93). Hence, we will first create the buffer in lat/long and then project them in Lambert-93.\n\ndist_buffer &lt;- 1000 # buffer of 1000 m\npoly_otter &lt;- buffer(pt_otter, dist_buffer)\n# project to Lambert-93\npoly_2154 &lt;- project(poly_otter, crs(bdalti))\n\n\n\n\n\n\n\nNoteNerdy\n\n\n\n\nCurious to know why it is recommended to create buffer in lat/long with terra? Try it out. Create buffer in Lambert-93 and check whether all buffers have the same size.\n\n\n\n\n\nClick to see the answer\n\n\n# create buffer directly in Lamber 93\nbuffer_2154 &lt;- buffer(pt_2154, 1000)\n# get the standard deviation of the area of the buffers\nsd(expanse(buffer_2154))\n\n[1] 1002.459\n\n# and compare it with the buffers created in lat/long\nsd(expanse(poly_2154))\n\n[1] 3.117107e-05\n\n\n\n\n\nGet average elevation\nThe function terra::extract() can summarize the information per polygon with the parameter fun. If no function is provided, it will extract all values that intersect the polygons.\nIt is recommended to use the parameter exact=TRUE to get the weighted mean based on the fraction of each cell that is covered (but computation is slower).\n\nmean_alti &lt;- extract(alti_masked, poly_2154, fun = mean, exact = TRUE)\n\nplot(\n  mean_alti$elevation,\n  pt_otter$elevation,\n  xlab = \"mean elevation in buffer (m)\",\n  ylab = \"elevation at the observation (m)\"\n)\n\n\n\n\n\n\n\n\n\n\nGet all values within buffers\nTo understand how the function extract works, it is helpful to extract all values.\n\nfull_alti &lt;- extract(alti_masked, poly_2154, exact = TRUE)\nhead(full_alti)\n\n  ID elevation   fraction\n1  1  232.2320 0.04703028\n2  1  222.9880 0.13675144\n3  1  218.9846 0.02927423\n4  1  203.8373 0.06348854\n5  1  231.5380 0.63766422\n6  1  221.8044 0.98195943\n\n\nEach row is a cell that is matching a polygon. elevation is the elevation value of the cell, fraction is the fraction of the cell covered by the polygon, and ID is the identifier of the intersecting polygon.\nWe can calculate the number of different pixels that intersects the polygon.\n\nnpixels &lt;- table(full_alti$ID)\ntable(npixels)\n\nnpixels\n63 64 65 66 67 68 69 \n 1  3  2  7 18 44  8 \n\n\nThe polygons intersect between 63 and 69 pixels, but some are partially intersecting. Let’s now calculate the surface (in number of pixels) covered by the buffer\n\narea_per_id &lt;- tapply(full_alti$fraction, full_alti$ID, sum)\nsummary(area_per_id)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  50.05   50.07   50.07   50.08   50.09   50.12 \n\n\nThe buffers cover an area equivalent to 50 full pixels.\nAn interesting ecological variable that we can calculate with data for each pixel is the range of the elevation found within the buffer.\n\ndrange_alti &lt;- tapply(full_alti$elevation, full_alti$ID, function(x) {\n  diff(range(x))\n})\n\nplot(\n  mean_alti$elevation,\n  drange_alti,\n  xlab = \"mean elevation in buffer (m)\",\n  ylab = \"elevation range in buffer (m)\"\n)",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/22_multilayer.html",
    "href": "chapters/22_multilayer.html",
    "title": "Multi-layer rasters",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "Rasters",
      "Multi-layer rasters"
    ]
  },
  {
    "objectID": "chapters/22_multilayer.html#setup",
    "href": "chapters/22_multilayer.html#setup",
    "title": "Multi-layer rasters",
    "section": "",
    "text": "Follow the setup instructions if you haven’t followed previous tutorials\n\nIf haven’t done it already, please follow the setup instructions.\nLet’s start with loading the required packages.\n\nsuppressPackageStartupMessages({\n  library(mapview)\n  library(here)\n  library(terra)\n})\n\nNow load the observations of otters recorded in 2021 within a 50km buffer from Montpellier, France.\n\nlocalonline\n\n\n\npt_otter &lt;- vect(here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\n\n\n\n\npt_otter &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.gpkg\"\n)",
    "crumbs": [
      "Rasters",
      "Multi-layer rasters"
    ]
  },
  {
    "objectID": "chapters/22_multilayer.html#load-monthly-climate-data",
    "href": "chapters/22_multilayer.html#load-monthly-climate-data",
    "title": "Multi-layer rasters",
    "section": "Load monthly climate data",
    "text": "Load monthly climate data\nWe will use the monthly average temperature data from CHELSA which has a spatial resolution of 1km. To see how we created the data for our case study, have a look at this tutorial.\n\nImport\nThe function to import most kind of raster file in  is terra::rast()\n\nlocalonline\n\n\n\ntemperature &lt;- rast(here(\"data\", \"CHELSA_monthly_tas_2015_2021.tif\"))\n\n\n\n\nurl_github &lt;- \"https://github.com/FRBCesab/spatial-r/raw/main/data/\"\ntemperature &lt;- rast(paste0(url_github, \"CHELSA_monthly_tas_2015_2021.tif\"))\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nWhat are the dimensions of the loaded temperature raster?\nWhat is the resolution of rasters? In which unit?\nWhat are the different layers and how can we get their names?\n\n\n\n\n\nClick to see the answer\n\n\nThere are 116 rows, 165 columns and 84 layers in the raster. You can access it with dim(temperature) or just by typing temperature in the console.\n\nThe spatial resolution of raster is 0.0083 decimal degrees (equal to 30 arc seconds). The resolution is expressed in degrees because the projection system is WGS 84 (EPSG 4326). You can access these information with res(temperature) and crs(temperature, describe = TRUE) or just by typing temperature in the console.\n\nThe different layers correspond to monthly averaged temperature. To access the name of the layers, type names(temperature).\n\n\n\n\nRename\nTo simplify the next steps, we will rename the layers with only their corresponding month and year.\n\n# shorten names\ntime_chelsa &lt;- substr(names(temperature), 12, 18)\nnames(temperature) &lt;- time_chelsa\n\n\n\nVisualize\nLet’s visualize the monthly temperature of 2021 with the function plot(). To set a commun color scale among layers, we use the parameter range.\n\n# select the layers of 2021\nin_2021 &lt;- grep(\"2021\", time_chelsa)\n\n# plot the 2021 temperature layers\nplot(temperature, in_2021, range = range(values(temperature)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nWhat is the unit of the temperature values?\nMask the sea from the temperature raster with the land boundary of France (as in the Chapter Rasters).\n\n\n\n\n\nClick to see the answer 1\n\nThe temperature are expressed in Kelvin, as indicated in the documentation of Chelsa-monthly dataset\n\n\n\nClick to see the answer 2\n\n\n# get the border of the country (level = 0)\nfrance_border &lt;- readRDS(here(\"data\", \"gadm41_FRA_0_pk.rds\"))\n# or directly from geodata\n# france_border &lt;- geodata::gadm(\"FRA\", level = 0, path = here(\"data\"))\n\n# mask (=set to NA) the pixels that are not in the polygon\ntemperature &lt;- mask(temperature, france_border)\n\nplot(\n  temperature,\n  in_2021,\n  range = range(values(temperature))\n)\n\n\n\n\n\n\n\n\n\n\n\nTransform in degree Celsius\nWe can make algebra operations in rasters. For instance, we can transform Kelvin to degree celsius.\n\ntemp_C &lt;- temperature - 273.15\n# calculate the range of temperature values\nrange_T &lt;- range(values(temp_C), na.rm = TRUE)\n# add otters observations in each layer with `fun`\nplot(\n  temp_C,\n  in_2021,\n  range = range_T,\n  plg = list(title = \"(°C)\"),\n  fun = function() points(pt_otter)\n)",
    "crumbs": [
      "Rasters",
      "Multi-layer rasters"
    ]
  },
  {
    "objectID": "chapters/22_multilayer.html#extract-information-on-points",
    "href": "chapters/22_multilayer.html#extract-information-on-points",
    "title": "Multi-layer rasters",
    "section": "Extract information on points",
    "text": "Extract information on points\nSimilar to simple raster, the function terra::extract() will get the temperature values of all months (= all layers) at the location of the observations.\n\npt_temp &lt;- extract(temp_C, pt_otter, ID = FALSE)\ndim(pt_temp)\n\n[1] 83 84\n\nsummary(unlist(pt_temp))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.95    9.55   13.75   14.69   20.55   26.95 \n\n\nThe extracted temperature (in pt_temp) are stored in a data.frame with rows corresponding to otters observations, and columns corresponding to months.\nWe can visualize the seasonal variation of the temperature with a simple boxplot()\n\n# plot the seasonal variation of the mean temperature\nboxplot(pt_temp, las = 2, ylab = \"Temperature (*C)\")\n\n\n\n\n\n\n\n\n\nAverage temperature\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nHaving one temperature variable per month is not informative, because these variables are highly correlated. So we need to summarize the information in term of average temperature or seasonal variation.\n\n\nWith these monthly temperature values, we can calculate the average of monthly temperature for the period 2015-2021.\n\n# apply(x, 1, mean) will calculate the mean over rows\nmean_temp &lt;- apply(pt_temp, 1, mean, na.rm = TRUE)\n# distribution of average values\nsummary(mean_temp)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  10.74   14.04   14.74   14.69   15.76   16.31 \n\n# attach the temperature as an attribute\npt_otter$mean_temp &lt;- mean_temp\n\n# let's map the average temperature\nplot(\n  pt_otter,\n  \"mean_temp\",\n  type = \"continuous\",\n  main = \"Average 2015-2021 temperature\",\n  plg = list(title = \"(°C)\")\n)\nplot(france_border, add = TRUE)\n\n\n\n\n\n\n\n\n\n\nSeasonal variations\nAnother interesting indicators is the seasonality of monthly temperature, which we can measure as the coefficient of variation (= the ratio of the standard deviation to the mean).\n\n# calculate the standard deviation\nsd_temp &lt;- apply(pt_temp, 1, sd, na.rm = TRUE)\n# get the coefficient of variation\ncv_temp &lt;- sd_temp / mean_temp\n# distribution of temperature seasonality\nsummary(cv_temp)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.3334  0.3823  0.4326  0.4185  0.4445  0.5517 \n\n# let's map the temperature seasonality\n# attach the value to the spatial points\npt_otter$cv_temp &lt;- cv_temp\n# create the map\nplot(\n  pt_otter,\n  \"cv_temp\",\n  main = \"Temperature seasonality\",\n  type = \"continuous\"\n)\nplot(france_border, add = TRUE)\n\n\n\n\n\n\n\n\nObservations made closer to the sea have warmer climate and lower seasonal variations in temperature.\n\n\nTemperature at the time of observation\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nInstead of the average climate in the time period 2015-2021, otters observations might also be affected by the weather at the time of observation (here approximated by the month of the observation).\n\n\nWe need to identify which temperature layer correspond to the time of the observations. For this we will use the date formatting in . If you want more details, have a look at the documentations of as.Date() and strptime() .\n\npt_otter$time &lt;- as.Date(pt_otter$eventDate) |&gt; format(\"%m_%Y\")\n\ntable(pt_otter$time)\n\n\n01_2021 02_2021 03_2021 04_2021 05_2021 06_2021 07_2021 08_2021 09_2021 10_2021 \n     12      11      11       8       3       6       4       3       6       7 \n11_2021 12_2021 \n      5       7 \n\n\nWe now have the same format for the name of the temperature layer and the time of the observations, so we can get the temperature value at the time of observation.\n\n# identify the matching layer corresponding to the time of observation\nt_obs &lt;- match(pt_otter$time, names(pt_temp))\n\n# get the values\nxy &lt;- cbind(1:nrow(pt_otter), t_obs)\npt_otter$temp_obs &lt;- pt_temp[xy]\n\n# distribution of the monthly temperature corresponding to the observation\nsummary(pt_otter$temp_obs)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   4.55    7.75   10.35   12.44   15.75   23.85 \n\n# mapping the new indicator\nplot(\n  pt_otter,\n  \"temp_obs\",\n  main = \"Monthly temperature\",\n  type = \"continuous\",\n  plg = list(title = \"(°C)\")\n)\nplot(france_border, add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nExtract the average temperature in 2015-2021 for 1km buffers around the observations. Use buffers as explained in the Chapter Rasters.\n(advanced) Make monthly temperature maps with corresponding observations overlaid\n(advanced) Calculate the range of monthly temperature within the 12 months before the observations, and make a map.\n\n\n\n\n\nClick to see the answer 1\n\n\n# create buffers\npoly_otter &lt;- buffer(pt_otter, 1000) # buffer of 1km\n# no need to project because everything is in WGS84\n# extract values for each layer\nmean_buffer_temp &lt;- extract(\n  temp_C,\n  poly_otter,\n  fun = mean,\n  exact = TRUE,\n  ID = FALSE\n)\nboxplot(mean_buffer_temp, las = 2, ylab = \"Temperature (*C)\")\n\n\n\n\n\n\n\n\n\n\n\nClick to see the answer 2\n\n\n# option with a for loop:\npar(mfrow = c(3, 4), mar = c(4, 4, 4, 1))\nfor (i in grep(\"2021\", time_chelsa, value = TRUE)) {\n  plot(temp_C, i, range = range_T, plg = list(title = \"(°C)\"), main = i)\n  points(pt_otter[pt_otter$time == i, ])\n}\n\n\n# option in a single line using plot()\nplot(\n  temp_C,\n  in_2021,\n  range = range_T,\n  plg = list(title = \"(°C)\"),\n  fun = function(i) {\n    points(pt_otter[pt_otter$time == names(temp_C)[in_2021][i], ])\n  }\n)\n\n\n\n\n\n\n\n\n\n\n\nClick to see the answer 3\n\n\n# we start from the matching time\nt_obs &lt;- match(pt_otter$time, names(pt_temp))\n# then we want to get 11 months before the observation\nt_past &lt;- t_obs - 11 # ideally check if not negative\n\n# calculate the difference of min-max value within the time period\ntemp_past12m &lt;- sapply(1:nrow(pt_temp), function(i) {\n  diff(range(pt_temp[i, t_past[i]:t_obs[i]]))\n})\n\n# distribution of the temperature range\nsummary(temp_past12m)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  16.00   17.35   18.00   17.81   18.60   20.00 \n\n# attach to the attribute table\npt_otter$temp_range_12m &lt;- temp_past12m\n\n# visualize the results\nplot(\n  pt_otter,\n  \"temp_range_12m\",\n  main = \"Past 12-months temperature range\",\n  type = \"continuous\",\n  plg = list(title = \"(°C)\")\n)\nplot(france_border, add = TRUE)",
    "crumbs": [
      "Rasters",
      "Multi-layer rasters"
    ]
  },
  {
    "objectID": "chapters/23_grid.html",
    "href": "chapters/23_grid.html",
    "title": "Grid",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "Rasters",
      "Grid"
    ]
  },
  {
    "objectID": "chapters/23_grid.html#setup",
    "href": "chapters/23_grid.html#setup",
    "title": "Grid",
    "section": "",
    "text": "Follow the setup instructions if you haven’t followed previous tutorials\n\nIf haven’t done it already, please follow the setup instructions.\nLet’s start with loading the required packages.\n\nsuppressPackageStartupMessages({\n  library(mapview)\n  library(here)\n  library(terra)\n})\n\nNow load all the datasets attached to the observations of otters recorded in 2021 within a 50km buffer from Montpellier, France.\n\npt_otter &lt;- vect(here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\nriver &lt;- vect(here(\"data\", \"BDCARTO-River_mpl50km.gpkg\"))\nlanduse &lt;- vect(here(\"data\", \"BDCARTO-LULC_mpl50km.shp\"))\nbdalti &lt;- rast(here(\"data\", \"BDALTI_mpl50km.tif\"))\ntemperature &lt;- rast(here(\"data\", \"CHELSA_monthly_tas_2015_2021.tif\"))",
    "crumbs": [
      "Rasters",
      "Grid"
    ]
  },
  {
    "objectID": "chapters/23_grid.html#create-a-grid",
    "href": "chapters/23_grid.html#create-a-grid",
    "title": "Grid",
    "section": "Create a grid",
    "text": "Create a grid\nCreating a grid requires a defined spatial resolution and a projection system. These choices depend on your dataset, its extent, and your modeling objectives.\nIn our case, we will create a grid of 5km around the otters observations using the Lambert-93 projection (EPSG:2154).\nThe function terra::rast() can create empty grid from the extent of a given spatial object. Here we provide the otters observation (projected in EPSG 2154) as the extent of our grid.\n\npt_2154 &lt;- project(pt_otter, \"EPSG:2154\")\nres &lt;- 5000 # 5km grid\ngrid &lt;- rast(pt_2154, res = res)\ngrid\n\nclass       : SpatRaster \nsize        : 17, 19, 1  (nrow, ncol, nlyr)\nresolution  : 5000, 5000  (x, y)\nextent      : 723524.6, 818524.6, 6245001, 6330001  (xmin, xmax, ymin, ymax)\ncoord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154)",
    "crumbs": [
      "Rasters",
      "Grid"
    ]
  },
  {
    "objectID": "chapters/23_grid.html#points-to-grid",
    "href": "chapters/23_grid.html#points-to-grid",
    "title": "Grid",
    "section": "Points to grid",
    "text": "Points to grid\nThe function terra::rasterize() transform vectors to raster. Its argument fun=count defines that the values in the cells are the number of points. The argument background=0 set that the value of the cells with no observation will be 0, instead of NA by default.\n\ngrid_nobs &lt;- rasterize(pt_2154, grid, fun = \"count\", background = 0)\n\nplot(grid_nobs, main = \"Number of otter observations\")",
    "crumbs": [
      "Rasters",
      "Grid"
    ]
  },
  {
    "objectID": "chapters/23_grid.html#lines-to-grid",
    "href": "chapters/23_grid.html#lines-to-grid",
    "title": "Grid",
    "section": "Lines to grid",
    "text": "Lines to grid\nTo calculate the length of rivers within a grid cell, we use the function terra::rasterizeGeom(). Its argument fun=length defines that the values in the cells are the length of the rivers.\n\nriver_2154 &lt;- project(river, \"EPSG:2154\")\n\ngrid_river &lt;- rasterizeGeom(river_2154, grid, fun = \"length\")\nplot(grid_river, main = \"Length of rivers\", plg = list(title = \"(m)\"))",
    "crumbs": [
      "Rasters",
      "Grid"
    ]
  },
  {
    "objectID": "chapters/23_grid.html#polygon-to-grid",
    "href": "chapters/23_grid.html#polygon-to-grid",
    "title": "Grid",
    "section": "Polygon to grid",
    "text": "Polygon to grid\nTo calculate the percentage of forest in the grid cells, we need first to consider only forest polygons. Then the function terra::rasterize() with the option cover=TRUE calculates the percentage of forest cover per grid cell.\n\n# select only the forest\nforest &lt;- landuse[landuse$nature == \"Forêt\"]\n# project the polygons\nforest_2154 &lt;- project(forest, \"EPSG:2154\")\n# rasterize\ngrid_forest &lt;- rasterize(forest_2154, grid, cover = TRUE, background = 0)\n\nplot(grid_forest, main = \"Forest cover\", plg = list(title = \"(%)\"))",
    "crumbs": [
      "Rasters",
      "Grid"
    ]
  },
  {
    "objectID": "chapters/23_grid.html#resample-raster",
    "href": "chapters/23_grid.html#resample-raster",
    "title": "Grid",
    "section": "Resample raster",
    "text": "Resample raster\nFor rasters, we need to transform the original grid to the desired resolution and extent. This operation is done with the function terra::resample(). Be careful, this operation degrades the quality of the original raster. Each cell get the weighted average of the neighboring cells.\n\nElevation\n\ngrid_alti &lt;- resample(bdalti, grid, method = \"bilinear\")\nplot(grid_alti, main = \"Elevation\", plg = list(title = \"(m)\"))\n\n\n\n\n\n\n\n\n\n\nTemperature\nFor CHELSA temperature rasters, we will keep only a summary of 2021: the average temperature over the 12 months of 2021. So we will (1) select only layers that correspond to 2021 (year of the observations) (2) calculate the average, (3) project the raster, and (4) resample to the desired grid.\n\n#1 select the layers corresponding to 2021\nin_2021 &lt;- grep(\"2021\", names(temperature))\nmonthly_temp &lt;- subset(temperature, in_2021)\n#2. calculate the average temperature in 2021\nannual_temp &lt;- mean(monthly_temp, na.rm = TRUE)\n# 3. project to EPSG 2154\ntemp_2154 &lt;- project(annual_temp, \"EPSG:2154\")\n# 4. resample to grid\ngrid_temp &lt;- resample(temp_2154, grid, \"bilinear\")\n\nplot(grid_temp, main = \"Av. temperature\", plg = list(title = \"(K)\"))",
    "crumbs": [
      "Rasters",
      "Grid"
    ]
  },
  {
    "objectID": "chapters/23_grid.html#merge-all-together",
    "href": "chapters/23_grid.html#merge-all-together",
    "title": "Grid",
    "section": "Merge all together",
    "text": "Merge all together\nIn terra, we can group SpatRaster objects into a single one if they all share the same grid. We will then get one grid and multiple layers (also called band) with the different informations.\n\n# merge all information into one single output\nout &lt;- c(grid_nobs, grid_river, grid_forest, grid_alti, grid_temp)\n# we rename the layers to keep information of units\nnames(out) &lt;- c(\"nobs\", \"river_m\", \"forest\", \"elevation_m\", \"temperature_K\")\n\nout\n\nclass       : SpatRaster \nsize        : 17, 19, 5  (nrow, ncol, nlyr)\nresolution  : 5000, 5000  (x, y)\nextent      : 723524.6, 818524.6, 6245001, 6330001  (xmin, xmax, ymin, ymax)\ncoord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154) \nsource(s)   : memory\nnames       : nobs,  river_m,    forest, elevation_m, temperature_K \nmin values  :    0,     0.00, 0.0000000,       0.000,      280.9530 \nmax values  :    7, 56861.96, 0.9665119,    1210.254,      289.1167 \n\nplot(out)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\nOur grid includes the Mediterranean Sea, but the otter observations were only made on land. Mask the created raster with the land boundary of France (as in the Chapter Rasters).\n\n\n\n\nClick to see the answer\n\n\n# get the border of the country (level = 0)\nfrance_border &lt;- readRDS(here(\"data\", \"gadm41_FRA_0_pk.rds\"))\n# or directly from geodata\n# france_border &lt;- geodata::gadm(\"FRA\", level = 0, path = here(\"data\"))\n# project the coast in Lambert-93\nfrance_2154 &lt;- project(france_border, crs(bdalti))\n# mask (=set to NA) the pixels that are not in the polygon\nout_masked &lt;- mask(out, france_2154)\nplot(out_masked)",
    "crumbs": [
      "Rasters",
      "Grid"
    ]
  },
  {
    "objectID": "chapters/23_grid.html#simple-linear-model",
    "href": "chapters/23_grid.html#simple-linear-model",
    "title": "Grid",
    "section": "Simple linear model",
    "text": "Simple linear model\nThe dataset is made of observations gathered without proper sampling schemes, and with potentially many biases. For such data (opportunistic presence-only data), it is recommended to use species occupancy models.\nYet, for our little case study we will do a simple linear model.\n\n# transform the spatial raster data as data.frame\ndf &lt;- data.frame(out_masked)\n\n# make a simple linear model\nm1 &lt;- lm(nobs ~ river_m + forest + elevation_m + temperature_K, data = df)\nsummary(m1)\n\n\nCall:\nlm(formula = nobs ~ river_m + forest + elevation_m + temperature_K, \n    data = df)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-0.6221 -0.3503 -0.2522 -0.0324  6.5679 \n\nCoefficients:\n                Estimate Std. Error t value Pr(&gt;|t|)   \n(Intercept)    2.584e+02  8.709e+01   2.967  0.00327 **\nriver_m       -6.591e-08  4.862e-06  -0.014  0.98920   \nforest        -2.689e-01  2.718e-01  -0.989  0.32331   \nelevation_m   -5.833e-03  2.081e-03  -2.803  0.00543 **\ntemperature_K -8.936e-01  3.014e-01  -2.965  0.00329 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.7884 on 276 degrees of freedom\nMultiple R-squared:  0.03659,   Adjusted R-squared:  0.02262 \nF-statistic:  2.62 on 4 and 276 DF,  p-value: 0.03531\n\n\nThe linear model is definitely not a good fit to our data (R2 is only 0.03). Moreover, there is strong collinearity between elevation and temperature, and the residuals are not normally distributed (to see how wrong is our model, try plot(m1)).\nIt might help if we use generalized mixed models. For zero-inflated datasets, one option is to make two separate models: (1) model the presence-absence as a binomial variable, and (2) model the number of observations with poisson distribution. Yet, in our case the main issue here is the high number of ‘false’ zeros (opportunistic observations, presence-only information) which can only be resolved with species occupancy models (e.g. spOccupancy).\nHowever, it is always recommended to spatially visualize the predictions and the residuals.\n\n# set new empty grids\nout_masked$predicted &lt;- rast(grid)\nout_masked$residuals &lt;- rast(grid)\n# add values of prediction and residuals where there is no NA\nout_masked$predicted[!is.na(out_masked$nobs)] &lt;- predict(m1)\nout_masked$residuals[!is.na(out_masked$nobs)] &lt;- residuals(m1)\n# show and compare the observation, prediction and residuals\nplot(out_masked, c(\"nobs\", \"predicted\", \"residuals\"), nc = 3)",
    "crumbs": [
      "Rasters",
      "Grid"
    ]
  },
  {
    "objectID": "chapters/31_toydata_mpl.html",
    "href": "chapters/31_toydata_mpl.html",
    "title": "Create a toy dataset from GBIF and IGN data",
    "section": "",
    "text": "1. Set the spatial extent\nThis is a small practical example on how get data from GBIF and IGN based on a geographical area. For this tutorial, we will need sf, mapview, happign, geodata, terra and rgbif packages.\nFor this example, we will focus on an area around FRB-CESAB in Montpellier. So we will need to\n(1) find the coordinates of FRB-CESAB (2) create a buffer area",
    "crumbs": [
      "Extra",
      "Create a toy dataset from GBIF and IGN data"
    ]
  },
  {
    "objectID": "chapters/31_toydata_mpl.html#set-the-spatial-extent",
    "href": "chapters/31_toydata_mpl.html#set-the-spatial-extent",
    "title": "Create a toy dataset from GBIF and IGN data",
    "section": "",
    "text": "Get coordinates from an address\nThis task is called geocoding. Among other resources, we recommend the package rgeoservices (if in France, based on french IGN services) or the package tidygeocoder using Open Street Map data.\n\nrgeoservicestidygeocodermanual\n\n\n\ncesab &lt;- rgeoservices::gs_get_coordinates(\n  query = \"5 rue de l’École de médecine, 34000 MONTPELLIER\",\n  index = \"address\"\n)\n\n\n\n\ncesab &lt;- tidygeocoder::geocode(\n  data.frame(x = \"5 rue de l’École de médecine, 34000 MONTPELLIER\"),\n  address = \"x\",\n  method = \"osm\"\n)\n# for compatibility with other solutions, rename the columns\nnames(cesab) &lt;- c(\"x\", \"latitude\", \"longitude\")\n\n\n\n\n# for such a simple case, it's easier to get coordinates from GoogleMap\n# https://maps.app.goo.gl/woqBZSs63zSjHUsS9\ncesab &lt;- data.frame(\n  \"latitude\" = 43.61269208391402,\n  \"longitude\" = 3.8733758693843585\n)\n\n\n\n\n\n\nCreate a spatial object from coordinates\nWe will use the function sf::st_as_sf() with the names of the columns for the longitude (x), the latitude (y) and the Coordinate Reference System (CRS) which is EPSG:4326.\n\n# create st_point\npt_cesab &lt;- st_as_sf(\n  cesab,\n  coords = c(\"longitude\", \"latitude\"),\n  crs = 4326\n)\n\n\n\nCreate a buffer area\nWe want a buffer zone of 50km around the FRB-Cesab. Because GBIF only accept rectangle buffer, we will take the square that include the circular buffer.\n\nbuffer_size &lt;- 50000 # in m\n\n# create a round buffer zone\nb_circle &lt;- st_buffer(pt_cesab, buffer_size)\n\n# transform to square because occ_search() needs rectangle\nb_square &lt;- st_bbox(b_circle) |&gt; st_as_sfc()\n\nWe can visualize the spatial data created with mapview:\n\nmapview(b_square, alpha.regions = 0, lwd = 3) +\n  mapview(b_circle, alpha.regions = 0.1, lwd = 0) +\n  mapview(pt_cesab)",
    "crumbs": [
      "Extra",
      "Create a toy dataset from GBIF and IGN data"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Appelhans, Tim, Florian Detsch, Christoph Reudenbach, and Stefan\nWoellauer. 2025. Mapview: Interactive Viewing of Spatial Data in\nr. https://doi.org/10.32614/CRAN.package.mapview.\n\n\nCarteron, Paul. 2025. Happign: R Interface to ’IGN’ Web\nServices. https://github.com/paul-carteron.\n\n\nChamberlain, Scott, Vijay Barve, Dan Mcglinn, Damiano Oldoni, Peter\nDesmet, Laurens Geffert, and Karthik Ram. 2025. Rgbif: Interface to\nthe Global Biodiversity Information Facility API. https://CRAN.R-project.org/package=rgbif.\n\n\nHijmans, Robert J. 2025a. Geodata: Access Geographic Data. https://github.com/rspatial/geodata.\n\n\n———. 2025b. Terra: Spatial Data Analysis. https://doi.org/10.32614/CRAN.package.terra.\n\n\nMüller, Kirill. 2025. Here: A Simpler Way to Find Your Files.\nhttps://here.r-lib.org/.\n\n\nPebesma, Edzer. 2018. “Simple Features for r: Standardized Support\nfor Spatial Vector Data.” The R Journal 10\n(1): 439–46. https://doi.org/10.32614/RJ-2018-009.",
    "crumbs": [
      "References"
    ]
  }
]