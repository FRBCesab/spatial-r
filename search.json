[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spatial-r: Tutorials on spatial data analysis in R",
    "section": "",
    "text": "Introduction\nThis is a collection of tutorials on how to handle spatial data in R. The tutorials target students and scientists in ecology with previous knowledge of the R software.\nThe core tutorial was developed for a two half-day workshop, but you can follow the tutorials at your own pace.\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nIn these tutorials, we characterize the habitat of otter that were observed in 2021 around Montpellier, France. This small toy case study is not relevant ecologically but provides a good opportunity to tackle multiple challenges with handling and collecting spatial data.\n\n\n\nR packages\nThe tutorials rely mostly on terra R-package as it was specifically developed to tackle all challenges faced by ecologists, agronomists or biologists when using spatial data.\nR has an exceptional diversity of users and packages, and this is especially true with the dynamic community around spatial data. Another popular package for handling spatial data is sf (and stars).\n\n\nWorkshop program\nHalf day 1: Vectors\n\nIntroduction to GIS: differences between vectors and rasters, short overview of coordinate reference system (CRS)\nPoints: Understand otter field observations as spatial points\nLines: Add infomation about river networks\n\nPolygons: Complete with land cover information as spatial polygons.\n\nHalf day 2: Rasters\n- raster: Discover what is a raster and get the elevation profile from field observation - multi layer: Trace back montly climate information at the field sites.\n\n\nOther tutorials\n\nToydata: how to get data from GBIF, IGN and CHELSA to create a toy dataset for the workshop?\n\nTo be created:\n- mapview - mapsf - tmap - tutoE1 : POLYGON: calculate convex hull, simplify geometries, aggregate, union, etc… spatial influence\n- tutoE2 : get data from WMS or WFS\n- tutoE3 : spatial autocorrelation - how to measure it, what to do about it? spatial regression model, local regression\n- tutoE4 : Krigging and interpolation\n- tutoE5 : remote sensing, landsat and modis\n- tutoE6 : GoogleEarthEngine, what it is and how to use it (mostly out of R)\n\n\nOther resources\nThese tutorials were inspired by brilliant online ressources, thanks to all of them:\n\nHijman R. et al. Spatial Data Science with R and “terra”\n\nPebesma and Bivand Spatial Data Science: With Applications in R\nMoraga P. (2023)Spatial Statistics for Data Science: Theory and Practice with R\nLovelace, Nowosad, and Muenchow (2025) Geocomputation with R\n\nGimond M. (2025) Intro to GIS and Spatial Analysis\n\nSlingsby J. (2025) A minimal introduction to GIS in R\nGiraud, T. et Pecout, H. (2025). Géomatique et cartographie avec R [fr]",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "chapters/01_setup.html",
    "href": "chapters/01_setup.html",
    "title": "Setup",
    "section": "",
    "text": "How to install R and set up a working environment\nThe tutorials rely on R, so you will need R installed and ideally a Please have a look at the tutorial on how to setup a working environment for scientific computing with R: https://frbcesab.github.io/rsetup/",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "chapters/01_setup.html#how-to-install-r-and-set-up-a-working-environment",
    "href": "chapters/01_setup.html#how-to-install-r-and-set-up-a-working-environment",
    "title": "Setup",
    "section": "",
    "text": "R packages needed for these tutorials\nWe will mostly use terra(Hijmans 2025), sf(Pebesma 2018), mapview(Appelhans et al. 2025), and exactextract.\n\nneeded_packages &lt;- c(\"terra\", \"sf\", \"mapview\", \"exactextract\")\n\ncheck_and_install &lt;- function(x) {\n  if (!requireNamespace(x, quietly = TRUE)) {\n    install.packages(x)\n  }\n}\n\ninvisible(lapply(needed_packages, check_and_install))\n\nInstalling package into '/home/romain/R/x86_64-pc-linux-gnu-library/4.5'\n(as 'lib' is unspecified)\n\n\nWarning: package 'exactextract' is not available for this version of R\n\nA version of this package for your version of R might be available elsewhere,\nsee the ideas at\nhttps://cran.r-project.org/doc/manuals/r-patched/R-admin.html#Installing-packages",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "chapters/01_setup.html#download-needed-dataset",
    "href": "chapters/01_setup.html#download-needed-dataset",
    "title": "Setup",
    "section": "Download needed dataset",
    "text": "Download needed dataset\nAs an toy dataset, the tutorials rely on observed occurrence of otter in 2021 around Montpellier, France. These dataset were downloaded directly from R, see the tutorial on creating a toy dataset from GBIF, IGN and CHELSA for more details.\nYou can run the following commands to download the dataset needed for the workshop (total size : 11Mb).\n\n# set data directory\ndatadir &lt;- here::here(\"data\")\nif (!dir.exists(datadir)) {\n  dir.create(\n    path = datadir,\n    showWarnings = FALSE,\n    recursive = TRUE\n  )\n}\n\n# download base url\nurl_git &lt;- \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data\"\n\n# download GBIF data (20kb)\nfile1 &lt;- \"gbif_otter_2021_mpl50km.csv\"\ndownload.file(file.path(url_git, file1), file.path(datadir, file1), mode = \"wb\")\n\n# download elevation data (500kb)\nfile2 &lt;- \"BDALTI_mpl50km.tif\"\ndownload.file(file.path(url_git, file2), file.path(datadir, file2), mode = \"wb\")\n\n# download administrative borders (2.5Mb)\nfile3 &lt;- \"BDCARTO-Commune_mpl50km.gpkg\"\ndownload.file(file.path(url_git, file3), file.path(datadir, file3), mode = \"wb\")\n\n# download rivers (2Mb)\nfile4 &lt;- \"BDCARTO-River_mpl50km.gpkg\"\ndownload.file(file.path(url_git, file4), file.path(datadir, file4), mode = \"wb\")\n\n# download land cover (3.7Mb)\nfile5 &lt;- \"BDCARTO-LULC_mpl50km\"\nshpext &lt;- c(\"dbf\", \"prj\", \"shp\", \"shx\")\nurl_shp &lt;- file.path(url_git, paste(file5, shpext, sep = \".\"))\ndir_shp &lt;- file.path(datadir, paste(file5, shpext, sep = \".\"))\nfor (i in seq_along(shpext)) {\n  download.file(url_shp[i], dir_shp[i], mode = \"wb\")\n}\n\n# download CHELSA monthly temperature (2.2Mb)\nfile6 &lt;- \"CHELSA_monthly_tas_2015_2021.tif\"\ndownload.file(file.path(url_git, file6), file.path(datadir, file6), mode = \"wb\")\n\n\n\n\n\n\nAppelhans, Tim, Florian Detsch, Christoph Reudenbach, and Stefan Woellauer. 2025. Mapview: Interactive Viewing of Spatial Data in r. https://doi.org/10.32614/CRAN.package.mapview.\n\n\nHijmans, Robert J. 2025. Terra: Spatial Data Analysis. https://doi.org/10.32614/CRAN.package.terra.\n\n\nPebesma, Edzer. 2018. “Simple Features for r: Standardized Support for Spatial Vector Data.” The R Journal 10 (1): 439–46. https://doi.org/10.32614/RJ-2018-009.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "chapters/02_presentation_gis.html",
    "href": "chapters/02_presentation_gis.html",
    "title": "Introduction to GIS",
    "section": "",
    "text": "NoteAn introduction to GIS\n\n\n\n   Source: https://github.com/FRBCesab/spatial-slides   Slides: https://frbcesab.github.io/spatial-slides/intro-GIS",
    "crumbs": [
      "Introduction to GIS"
    ]
  },
  {
    "objectID": "chapters/11_points.html",
    "href": "chapters/11_points.html",
    "title": "Points",
    "section": "",
    "text": "Setup\nIf you haven’t done it already, please follow the setup instructions. Let’s start with loading the required packages.\nsuppressPackageStartupMessages({\n  library(terra)\n  library(mapview)\n  library(here)\n  library(sf)\n})",
    "crumbs": [
      "Vectors",
      "Points"
    ]
  },
  {
    "objectID": "chapters/11_points.html#creating-spatial-points-from-data.frame",
    "href": "chapters/11_points.html#creating-spatial-points-from-data.frame",
    "title": "Points",
    "section": "Creating spatial points from data.frame",
    "text": "Creating spatial points from data.frame\nThis is the most common case: you have coordinates from a file (csv or excel) and you want to get spatial information about these locations. The first step is to transform the coordinates as proper spatial object in R.\nWe will use a dataset from GBIF with all occurrences of otter recorded in 2021 within a 50km buffer from Montpellier, France. This data was prepared from the tutorial about creating a toy dataset and is stored on Github.\n\nlocalonline\n\n\n\notter &lt;- read.csv(here(\"data\", \"gbif_otter_2021_mpl50km.csv\"))\n\n\n\n\notter &lt;- read.csv(\n  \"https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.csv\"\n)\n\n\n\n\n\ndim(otter)\n\n[1] 83 14\n\nnames(otter)\n\n [1] \"key\"                              \"institutionCode\"                 \n [3] \"species\"                          \"occurrenceStatus\"                \n [5] \"eventDate\"                        \"year\"                            \n [7] \"month\"                            \"day\"                             \n [9] \"decimalLongitude\"                 \"decimalLatitude\"                 \n[11] \"elevation\"                        \"identificationVerificationStatus\"\n[13] \"identifier\"                       \"datasetKey\"                      \n\n\nThe dataset contains 83 observations of otter (in rows), and 14 variables (in column) such as date, coordinates, and data provider. The geographic coordinates are stored in the columns decimalLongitude, and decimalLatitude. They are expressed in decimal degrees, following the standard WGS84 datum (EPSG:4326).\n\n\n\n\n\n\nImportant\n\n\n\nIt is really important to keep track of the projection system of your data. When it is expressed in latitude-longitude and was derived from modern GPS, it is often in WGS84 (EPSG:4326). Problems arise when coordinates are expressed in meters, then it is complicated to retrieve the projection system if not stored with the data.\n\n\nWe have just loaded in R the observations from GBIF, but it is stored in a simple data.frame object, R doesn’t know that it contains spatial information yet. Let’s create a spatial object from the coordinates so that we can easily make a map and see where these observation were made.\n\nterrasf\n\n\nIn terra, the key function for vectors is terra::vect().\n\npt_terra &lt;- vect(\n  otter,\n  geom = c(\"decimalLongitude\", \"decimalLatitude\"),\n  crs = \"EPSG:4326\"\n)\n# summary\npt_terra\n\n class       : SpatVector \n geometry    : points \n dimensions  : 83, 12  (geometries, attributes)\n extent      : 3.28983, 4.46447, 43.30373, 44.06548  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :       key institutionCode     species occurrenceStatus\n type        :     &lt;num&gt;           &lt;chr&gt;       &lt;chr&gt;            &lt;chr&gt;\n values      : 3.059e+09     iNaturalist Lutra lutra          PRESENT\n               3.854e+09    UAR PatriNat Lutra lutra          PRESENT\n               3.854e+09    UAR PatriNat Lutra lutra          PRESENT\n       eventDate  year month   day elevation identificationVerificationStatus\n           &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;                            &lt;chr&gt;\n 2021-01-24T15:~  2021     1    24        NA                               NA\n      2021-01-13  2021     1    13        NA                         Probable\n      2021-01-08  2021     1     8        NA                         Probable\n      identifier      datasetKey\n           &lt;chr&gt;           &lt;chr&gt;\n        68608477 50c9509d-22c7-~\n 5b4c3803-50a9-~ c32f3129-a4dc-~\n cc533347-f1e3-~ c32f3129-a4dc-~\n\n\nAll the information about the terra::SpatVector object can be retrieve individually with the functions terra::ext() for the geographical extent, terra::crs() for the projection system, and dim() for the dimensions (number of objects, and number of variables in the attribute table).\n\n\nIn sf, the key function is sf::st_as_sf().\n\npt_sf &lt;- st_as_sf(\n  otter,\n  coords = c(\"decimalLongitude\", \"decimalLatitude\"),\n  crs = \"EPSG:4326\"\n)\n# summary\npt_sf\n\nSimple feature collection with 83 features and 12 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3.28983 ymin: 43.30373 xmax: 4.46447 ymax: 44.06548\nGeodetic CRS:  WGS 84\nFirst 10 features:\n          key institutionCode     species occurrenceStatus           eventDate\n1  3058935748     iNaturalist Lutra lutra          PRESENT 2021-01-24T15:26:55\n2  3853886594    UAR PatriNat Lutra lutra          PRESENT          2021-01-13\n3  3853886619    UAR PatriNat Lutra lutra          PRESENT          2021-01-08\n4  3853886780    UAR PatriNat Lutra lutra          PRESENT          2021-01-12\n5  4546764953    UAR PatriNat Lutra lutra          PRESENT          2021-01-31\n6  4546968119    UAR PatriNat Lutra lutra          PRESENT          2021-01-17\n7  4547054813    UAR PatriNat Lutra lutra          PRESENT          2021-01-31\n8  4548321676    UAR PatriNat Lutra lutra          PRESENT          2021-01-23\n9  4548484387    UAR PatriNat Lutra lutra          PRESENT          2021-01-31\n10 4552966259    UAR PatriNat Lutra lutra          PRESENT          2021-01-06\n   year month day elevation identificationVerificationStatus\n1  2021     1  24        NA                             &lt;NA&gt;\n2  2021     1  13        NA                         Probable\n3  2021     1   8        NA                         Probable\n4  2021     1  12        NA                         Probable\n5  2021     1  31        NA                         Probable\n6  2021     1  17        NA                         Probable\n7  2021     1  31        NA                         Probable\n8  2021     1  23        NA                         Probable\n9  2021     1  31        NA                         Probable\n10 2021     1   6        NA                         Probable\n                             identifier                           datasetKey\n1                              68608477 50c9509d-22c7-4a22-a47d-8c48425ef4a7\n2  5b4c3803-50a9-465a-a1a7-35c4a4d7d508 c32f3129-a4dc-4e36-86d4-a35cc5cfb04d\n3  cc533347-f1e3-4cf3-9f55-2c7cf60500de c32f3129-a4dc-4e36-86d4-a35cc5cfb04d\n4  3210c6f2-391a-4cc4-b497-b915bbc9d7d4 c32f3129-a4dc-4e36-86d4-a35cc5cfb04d\n5  631348e0-646f-41eb-b3c7-01900054c689 256b9877-cef3-4e8e-84e1-f23299c49655\n6  754868ad-58ef-41eb-b3c7-01900054452d 256b9877-cef3-4e8e-84e1-f23299c49655\n7  771217f4-6470-41eb-b3c7-01900054c695 256b9877-cef3-4e8e-84e1-f23299c49655\n8  b00a76e4-907d-41eb-adf1-041006068357 256b9877-cef3-4e8e-84e1-f23299c49655\n9  b2343db5-646f-41eb-b3c7-01900054c693 256b9877-cef3-4e8e-84e1-f23299c49655\n10 33310104-5041-41eb-bfb5-01900053f23b 256b9877-cef3-4e8e-84e1-f23299c49655\n                    geometry\n1  POINT (3.792841 43.81636)\n2   POINT (3.46399 43.38562)\n3    POINT (3.28983 43.3172)\n4   POINT (3.83235 43.57202)\n5   POINT (3.46399 43.38562)\n6   POINT (3.92099 44.06548)\n7   POINT (3.85823 43.52581)\n8   POINT (3.57398 43.63949)\n9    POINT (3.28983 43.3172)\n10  POINT (3.54517 43.75695)\n\n\nAll the information about the sf object can be retrieve individually with the functions sf::st_bbox() for the geographical extent, sf::st_crs() for the projection system, and dim() for the dimensions (number of objects, and number of variables in the attribute table).",
    "crumbs": [
      "Vectors",
      "Points"
    ]
  },
  {
    "objectID": "chapters/11_points.html#map-the-observations",
    "href": "chapters/11_points.html#map-the-observations",
    "title": "Points",
    "section": "Map the observations",
    "text": "Map the observations\nOnce the data is formatted as spatial vector, it can be visualized as static map with the function plot() or interactively with the package mapview.\n\nmapviewterrasf\n\n\nThe function mapview::mapview() creates easily interactive map.\n\nmapview(pt_terra)\n\n\n\n\n\n\n\n\nplot(pt_terra)\n\n\n\n\n\n\n\n\n\n\nIn sf, the function plot() visualize the attributes of the vectors by default. If you want a simple map with only the geometry, use st_geometry().\n\nplot(st_geometry(pt_sf), axes = TRUE)",
    "crumbs": [
      "Vectors",
      "Points"
    ]
  },
  {
    "objectID": "chapters/11_points.html#add-new-attribute",
    "href": "chapters/11_points.html#add-new-attribute",
    "title": "Points",
    "section": "Add new attribute",
    "text": "Add new attribute\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nCan we see a temporal pattern in the locations of the otter observations?\n\n\nLet’s transform the date of the observation and get the Julian date of the observation. Then we can attach this new variable to the attribute table of our spatial object in order to map it.\nThe date formatting in R is powerful but hard to grasp at start. Make sure to have a look at the documentations of as.Date() and strptime() if you want more details.\n\n# transform the date as Julian day\njulian &lt;- as.Date(pt_terra$eventDate) |&gt; format(\"%j\")\n\nNow we can attach the Julian day as a number in the spatial object. The attribute table can be accessed as a normal data.frame, and we can create a new column with $.\n\nterrasf\n\n\n\npt_terra$julian &lt;- as.numeric(julian)\n\n\n\n\npt_sf$julian &lt;- as.numeric(julian)\n\n\n\n\n\ninteractiveterrasf\n\n\nTo map an attribute in mapview::mapview(), add the parameter zcol with the variable of interest.\n\nmapview(pt_terra, zcol = \"julian\")\n\n\n\n\n\n\n\n\nplot(pt_terra, \"julian\")\n\n\n\n\n\n\n\n\n\n\n\nplot(pt_sf[\"julian\"], axes = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\nVisually check if there is a spatial bias in observations due to data provider (information in the column institutionCode).\n\n\n\n\nClick to see the answer\n\n\nmapview(pt_sf, zcol = \"institutionCode\")\n# or\nplot(pt_terra, \"institutionCode\")\n# or\nplot(pt_sf[\"institutionCode\"], axes = TRUE)",
    "crumbs": [
      "Vectors",
      "Points"
    ]
  },
  {
    "objectID": "chapters/11_points.html#export-the-data",
    "href": "chapters/11_points.html#export-the-data",
    "title": "Points",
    "section": "Export the data",
    "text": "Export the data\nFor vectors, it is recommended to export them as geopackage file (extension .gpkg). Compare to traditional ESRI shapefile, the geopackage format store the data in a single file and the column names are preserved.\n\nterrasf\n\n\nIn terra, the function is terra::writeVector().\n\nwriteVector(pt_terra, here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\n\n\n\nIn sf, the function is sf::st_write(). or write_sf().\n\nst_write(pt_sf, here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))",
    "crumbs": [
      "Vectors",
      "Points"
    ]
  },
  {
    "objectID": "chapters/11_points.html#conversion-between-sf-and-terra",
    "href": "chapters/11_points.html#conversion-between-sf-and-terra",
    "title": "Points",
    "section": "Conversion between sf and terra",
    "text": "Conversion between sf and terra\nI agree that it is confusing to have two dominant packages terra and sf with similar functionalities. Luckily, the conversion between these two formats is easy.\n\nfrom terra to spfrom sf to terra\n\n\nTo convert a terra vector into sf, the function is sf::st_as_sf().\n\npt_sf &lt;- st_as_sf(pt_terra)\n\n\n\nTo convert a sf feature into terra, the function is terra::vect().\n\npt_terra &lt;- vect(pt_sf)\n\n\n\n\n\n\n\nWarning\n\n\n\nNon-homogeneous features (GEOMETRYCOLLECTION) can’t be converted as terra SpatVector object. In this case, you must homogenize the type of features, and transform them into an accepted format for terra (points, lines or polygons). Check out the functions sf::st_cast() and sf::st_collection_extract() that can help with this transformation.",
    "crumbs": [
      "Vectors",
      "Points"
    ]
  },
  {
    "objectID": "chapters/12_lines.html",
    "href": "chapters/12_lines.html",
    "title": "Lines",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "Vectors",
      "Lines"
    ]
  },
  {
    "objectID": "chapters/12_lines.html#setup",
    "href": "chapters/12_lines.html#setup",
    "title": "Lines",
    "section": "",
    "text": "Follow the setup instructions if you haven’t followed the tutorial on points\n\nIf haven’t done it already, please follow the setup instructions. Let’s start with loading the required packages.\n\nsuppressPackageStartupMessages({\n  library(mapview)\n  library(here)\n  library(sf)\n  library(terra)\n})\n\n\nlocalonline\n\n\n\npt_otter &lt;- vect(here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\n\n\n\n\npt_otter &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.gpkg\"\n)",
    "crumbs": [
      "Vectors",
      "Lines"
    ]
  },
  {
    "objectID": "chapters/12_lines.html#load-lines-from-a-geopackage-file",
    "href": "chapters/12_lines.html#load-lines-from-a-geopackage-file",
    "title": "Lines",
    "section": "Load lines from a geopackage file",
    "text": "Load lines from a geopackage file\nLines are made of multiple points. It is possible to create lines directly from coordinates but, in practice, it often comes from an existing spatial dataset. For our example, we will load rivers for the area of interest from IGN data BD CARTO.\nNote that dataset has rough resolution (BD TOPO would be more suited for real analysis), but it’s perfect for our illustration and learning purpose.\nYou can load all vector dataset in R with the function sf::st_read(). It can read many different formats. Another function sf::read_sf() is also available and return a similar spatial object but with a tibble instead of a data.frame as attribute table.\n\nterrasfonline\n\n\n\nriver &lt;- vect(here(\"data\", \"BDCARTO-River_mpl50km.gpkg\"))\n\n\n\n\nriver_sf &lt;- st_read(here(\"data\", \"BDCARTO-River_mpl50km.gpkg\"))\n\nReading layer `BDCARTO-River_mpl50km' from data source \n  `/home/romain/GitHub/spatial-r/data/BDCARTO-River_mpl50km.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2110 features and 8 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 3.18983 ymin: 43.21278 xmax: 4.56447 ymax: 44.16754\nGeodetic CRS:  WGS 84\n\n\n\n\n\nriver &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-River_mpl50km.gpkg\"\n)\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nHow many different lines of river was loaded?\nWhat is the coordinate reference system (CRS) of the loaded river data?\nHow can you get the name of the all the river stretches?\n\n\n\n\n\nClick to see the answer\n\n\nThere was 2110 lines in the dataset. You can access it with dim(river), nrow(river) or just by typing river in the console.\n\nThe coordinates are in WGS 84 (EPSG 4326). You can access this information with crs(river, describe = TRUE) (or in sf with st_crs(river_sf)).\nThe column that stored the name of river stretches is toponyme. You could identify it with head(river) or names(river). There are 151 river stretches without names (table(is.na(river$toponyme))).",
    "crumbs": [
      "Vectors",
      "Lines"
    ]
  },
  {
    "objectID": "chapters/12_lines.html#calculate-length-of-lines",
    "href": "chapters/12_lines.html#calculate-length-of-lines",
    "title": "Lines",
    "section": "Calculate length of lines",
    "text": "Calculate length of lines\n\nterrasf\n\n\nThe function terra::perim() While calculating distance and length, be careful with projection systems. Some are not suited to calculate distance. The package terra recommends the calculation of distances in lat/long to get more accurate results (considering the geodesic distance, so accounting for Earth’s curvature).\n\n# calculate the length of rivers (in km)\nriver$length_km &lt;- perim(river) / 1000\n\n\n\nThe function sf::st_length() calculate the length of lines. While calculating distance and length, be careful with projection systems. Some are not suited to calculate distance.It is recommended to use equidistant projections or use local projection system (if your study area is small).\n\n# calculate the length of rivers (in km)\nriver_sf$length_km &lt;- st_length(river_sf) / 1000\n\n\n\n\n\n# see the distribution of river length\nboxplot(river$length_km, ylab = \"length (km)\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nWhich is the longest river in our dataset?\n\n\n\n\n\n\nClick to see the answer\n\n\n# get the name of the longest river\nriver$toponyme[which.max(river$length_km)]\n\n[1] \"l'Hérault\"",
    "crumbs": [
      "Vectors",
      "Lines"
    ]
  },
  {
    "objectID": "chapters/12_lines.html#map-multiple-layers",
    "href": "chapters/12_lines.html#map-multiple-layers",
    "title": "Lines",
    "section": "Map multiple layers",
    "text": "Map multiple layers\nLet’s map the river and their length, as well as position of the otter observations.\n\ninteractiveterrasf\n\n\nYou can combine multiple layers in mapview with a +.\n\nmapview(river, zcol = \"length_km\") +\n  mapview(pt_otter, col.regions = \"red\", color = NA)\n\n\n\n\n\n\n\n\nplot(river, y = \"length_km\")\nplot(pt_otter, add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\nplot(river_sf[\"length_km\"], reset = FALSE, axes = TRUE)\nplot(pt_otter, add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIf you want to overlay multiple spatial object with base plot from sf, don’t forget to use the argument reset=FALSE.",
    "crumbs": [
      "Vectors",
      "Lines"
    ]
  },
  {
    "objectID": "chapters/12_lines.html#calculate-the-distance-to-the-closest-line",
    "href": "chapters/12_lines.html#calculate-the-distance-to-the-closest-line",
    "title": "Lines",
    "section": "Calculate the distance to the closest line",
    "text": "Calculate the distance to the closest line\n\n\n\n\n\n\nTipThe ecologist mind\n\n\n\nAt which distance from a river were the otter observed?\n\n\nThis question is addressed by the function terra::nearest().\nBefore comparing two spatial objects, it is recommended to plot the data (if not too big) and make sure the projection systems are the same and the extents match. In this case, do not use mapview (interactive map) because it will automatically project your data.\n\n# make sure the spatial objects have the same projection\nst_crs(river) == st_crs(pt_otter)\n\n[1] TRUE\n\n\n\nFind the closest river\n\nterrasf\n\n\n\n# Step 1: Find index of nearest line for each point\nnearest_river &lt;- nearest(pt_otter, river)\n\n\n\nIn sf, this is a two-step process: (1) find the closest river sf::st_nearest_feature() and (2) calculate the distance between points and their closest river sf::st_distance().\n\n# Step 1: Find index of nearest line for each point\nnearest_sf &lt;- st_nearest_feature(st_as_sf(pt_otter), river_sf)\n\nThe object nearest_river is a vector containing the index of the closest river for each otter observation.\n\n# Step 2: Calculate distance only to the nearest line\nnearest_distances &lt;- st_distance(\n  st_as_sf(pt_otter),\n  river_sf[nearest_sf, ],\n  by_element = TRUE\n)\n\n\n\n\n\nboxplot(nearest_distances, ylab = \"distance to river (m)\")\n\n\n\n\n\n\n\n# should check out discrepancy\n# plot(nearest_distances, nearest_river$distance)\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nWhich are the rivers with most sights of otter? answer doesn’t work anymore\nMake a map with the distance to river and visually check the coherence of the calculation.\n(Reflexion) How can you explain the large distances?\n\n\n\n\n\nClick to see the answer 1\n\n\ntable(river$toponyme[nearest_river]) |&gt;\n  sort(decreasing = TRUE) |&gt;\n  head(5)\n\n\n\n\nClick to see the answer 2\n\n\n# add the distance to river to the spatial object\npt_otter$dist_river &lt;- nearest_distances\n\n# make an interactive map\nmapview(river) +\n  mapview(pt_otter, z = \"dist_river\")\n\n# or static map\nplot(st_geometry(river))\nplot(pt_otter[, \"dist_river\"], add = TRUE, pch = 16)",
    "crumbs": [
      "Vectors",
      "Lines"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html",
    "href": "chapters/13_polygons.html",
    "title": "Polygons",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#setup",
    "href": "chapters/13_polygons.html#setup",
    "title": "Polygons",
    "section": "",
    "text": "Follow the setup instructions if you haven’t followed the tutorial on points\n\nIf haven’t done it already, please follow the setup instructions. Let’s start with loading the required packages.\n\nsuppressPackageStartupMessages({\n  library(mapview)\n  library(here)\n  library(sf)\n  library(terra)\n})\n\n\nlocalonline\n\n\n\npt_otter &lt;- st_read(here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\n\nReading layer `gbif_otter_2021_mpl50km' from data source \n  `/home/romain/GitHub/spatial-r/data/gbif_otter_2021_mpl50km.gpkg' \n  using driver `GPKG'\nSimple feature collection with 69 features and 13 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3.28983 ymin: 43.30373 xmax: 4.46447 ymax: 44.06548\nGeodetic CRS:  WGS 84\n\n\n\n\n\npt_otter &lt;- st_read(\n  \"https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.gpkg\"\n)",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#load-polygons-from-a-shapefile",
    "href": "chapters/13_polygons.html#load-polygons-from-a-shapefile",
    "title": "Polygons",
    "section": "Load polygons from a shapefile",
    "text": "Load polygons from a shapefile\nIn practice, most polygons come from existing spatial datasets (apart of grid addref). In this example, we will load land use land cover information for the area of interest from IGN data BD CARTO.\nNote that this dataset has rough resolution (OSO or Corine land cover would be more suited for real analysis), but it’s perfect for our illustration and learning purposes.\nYou can load all vector dataset in R with the function sf::st_read().\n\nlocalonline\n\n\n\nlanduse &lt;- st_read(here(\"data\", \"BDCARTO-LULC_mpl50km.shp\"))\n\nReading layer `BDCARTO-LULC_mpl50km' from data source \n  `/home/romain/GitHub/spatial-r/data/BDCARTO-LULC_mpl50km.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 2384 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 3.248306 ymin: 43.15835 xmax: 4.495429 ymax: 44.06731\nGeodetic CRS:  WGS 84\n\n\n\n\n\nlanduse &lt;- st_read(\n  \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-LULC_mpl50km.shp\"\n)\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nHow many different polygons make the land cover of the area?\nWhat is the coordinate reference system (CRS) of the loaded river data?\nHow many land cover classes are there? which class has most polygons?\n\n\n\n\n\nClick to see the answer\n\n\nThere was 2384 polygons in the dataset. You can access it with dim(landuse), nrow(landuse) or just by typing landuse in the console.\n\nThe coordinates are in WGS 84 (EPSG 4326). You can access this information with st_crs(landuse).\nThe column that stored the name of river stretches is nature. You could identify it with head(landuse) or names(landuse). There are 12 land cover classes, Prairie is the class with most polygons (table(landuse$nature)).",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#visualization",
    "href": "chapters/13_polygons.html#visualization",
    "title": "Polygons",
    "section": "Visualization",
    "text": "Visualization\n\ninteractivestatic\n\n\n\nmapview(landuse, z = \"nature\") +\n  mapview(pt_otter, col.regions = \"black\")\n\n\n\n\n\n\n\n\nplot(landuse[\"nature\"], reset = FALSE, border = FALSE, axes = TRUE)\nplot(st_geometry(pt_otter), add = TRUE, pch = 16)",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#calculate-the-area",
    "href": "chapters/13_polygons.html#calculate-the-area",
    "title": "Polygons",
    "section": "Calculate the area",
    "text": "Calculate the area\nThe function expanse calculate the area in \\(m^2\\). Again, be careful with projection systems (addrefslide). Some are not suited to calculate areas. Prefer equalarea projections or use local projection system (if your study area is small).\nThe package terra recommends the calculation of areas in lat/long to get more accurate results (accounting for Earth’s curvature). The package sf handle lat/long with s2 which is not very accurate or prone to errors.\nSo it is recommended to use terra when dealing with geographic coordinates, or projecting the coordinates in an appropriate projection system.\n\nterrasf\n\n\n\n# transform land use as SpatVector\nlanduse_terra &lt;- vect(landuse)\n# calculate the area in ha\narea_polygons &lt;- expanse(landuse_terra) * 0.0001\n# store the area as atribute\nlanduse_terra$area_ha &lt;- as.numeric(area_polygons)\n\n\n\n\n# 2154 is a commun projection for France\nlanduse_2154 &lt;- st_transform(landuse, crs = 2154)\n# calculate area of polygons\narea_polygons &lt;- st_area(landuse_2154)\n# transform in ha\nunits(area_polygons) &lt;- \"ha\"\n# same as st_area(landuse)) * 0.0001\n# store as attribute in landuse\nlanduse_2154$area_ha &lt;- as.numeric(area_polygons)\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nWhich is the largest land cover class in our study area?\nCompare the area calculation of terra, sf.\n\n\n\n\n\nClick to see the answer\n\n\n# see area per land use classes\ntapply(landuse_terra$area_ha, landuse$nature, sum) #/sum(landuse_terra$area_ha) * 100\n\n              Bâti       Broussailles Carrière, décharge          Eau libre \n       47485.21879        89142.56281         1624.44372       279914.24086 \n             Forêt      Marais salant  Marais, tourbière            Prairie \n      180470.59831         3386.96654        23674.11376       160747.53153 \n   Rocher, éboulis     Sable, gravier      Vigne, verger   Zone d'activités \n          37.78454         1875.32616       175294.25395        13725.54131 \n\ntapply(landuse_2154$area_ha, landuse$nature, sum) #/sum(landuse_2154$area_ha) * 100\n\n              Bâti       Broussailles Carrière, décharge          Eau libre \n        47509.9590         89177.4533          1625.3989        280220.8782 \n             Forêt      Marais salant  Marais, tourbière            Prairie \n       180509.0654          3389.7172         23692.1565        160809.4575 \n   Rocher, éboulis     Sable, gravier      Vigne, verger   Zone d'activités \n           37.7996          1876.9749        175391.1066         13734.7157",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#points-to-polygons",
    "href": "chapters/13_polygons.html#points-to-polygons",
    "title": "Polygons",
    "section": "Points to polygons",
    "text": "Points to polygons\nBefore making extraction, it is recommended to plot the data (if not too big), to make sure the projection systems are the same and the extents match. Do not use mapview (interactive map) because it will automatically project the data.\n\nsfterra\n\n\nExtract the land cover class of the points with sf::st_join():\n\npt_landcover &lt;- st_join(pt_otter, landuse)\n\n\n\nExtract the land cover class of the points with terra::extract():\n\n# transform land use as SpatVector\npt_otter_terra &lt;- vect(pt_otter)\n# overlay points and polygon with extract()\npt_landcover_terra &lt;- extract(landuse_terra, pt_otter_terra)\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nWhich is the most commun land cover classes where otter were observed?\n\n[stat] Are there classes that are over or under represented compare to expected?\n\n\n\n\n\nClick to see the answer\n\n\n# see area per land use classes of the observations\nsort(table(pt_landcover$nature), decreasing = TRUE)[1:5]\n\n\n        Forêt  Broussailles       Prairie Vigne, verger          Bâti \n           24            14            14             8             7",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/13_polygons.html#polygons-to-polygons",
    "href": "chapters/13_polygons.html#polygons-to-polygons",
    "title": "Polygons",
    "section": "Polygons to polygons",
    "text": "Polygons to polygons\nIn many cases, we want to characterize the area surrounding the observations. So we will create buffers.\n\nCreate buffer\n\nsfterra\n\n\nSame here, sf is really not good with geographic coordinates (e.g. EPSG:4326) so it’s better to project the points before creating the buffer with sf. with sf::st_buffer().\n\ndist_buffer &lt;- 1000 # buffer of 1000 m\npt_otter_2154 &lt;- st_transform(pt_otter, 2154)\npoly_otter_2154 &lt;- st_buffer(pt_otter_2154, dist_buffer)\n\n\n\nwith terra::buffer().\n\ndist_buffer &lt;- 1000 # buffer of 1000 m\npoly_otter_terra &lt;- buffer(pt_otter_terra, dist_buffer)\n\n\n\n\n\n\nVisualize buffer\n\nsfterra\n\n\n\nplot(st_geometry(poly_otter_2154)[1], reset = FALSE)\nplot(st_geometry(pt_otter_2154)[1], add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\nplot(poly_otter_terra[1])\nplot(pt_otter_terra[1], add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteYour turn\n\n\n\n\nWhat is the area of the newly created buffers?\n\n\n\n\n\nClick to see the answer\n\n\n# see area per land use classes of the observations\nsummary(st_area(poly_otter_2154))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n3140157 3140157 3140157 3140157 3140157 3140157 \n\nsummary(expanse(poly_otter_terra))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n3128689 3128689 3128689 3128689 3128689 3128689 \n\n\n\nThe difference is due to the curvature of earth, in projected coordinates we have the planar area (which should theoretically be 3141593 m2), and in geographic coordinates we have geodesic area.\n\n\nintersection\n\nsfterra\n\n\n\nbuffer_landcover &lt;- st_intersection(poly_otter_2154, landuse_2154)\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\n# visualize the intersection\nmapview(buffer_landcover, z = \"nature\")\n\n\n\n\n\n\n\n\nbuffer_landcover_terra &lt;- intersect(landuse_terra, poly_otter_terra)\n\n# visualize the intersection\nmapview(buffer_landcover_terra, z = \"nature\")\n\n\n\n\n\n\n\n\n\n\ncovers\n\nsfterra\n\n\n\nbuffer_landcover$area_ha &lt;- st_area(buffer_landcover) * 0.0001\n\nocc &lt;- tapply(\n  buffer_landcover$area_ha,\n  list(buffer_landcover$X, buffer_landcover$nature),\n  sum\n)\n#replace NA by 0\nocc[is.na(occ)] &lt;- 0\n# calculate the overlay area\nsum_occ &lt;- rowSums(occ)\n# calculate the percentage per class\nperc_occ &lt;- occ / sum_occ * 100\n\n# add information in the spatial vector\n# pt_res &lt;- cbind(pt_otter, perc_occ)\n# mapview(pt_res, z = \"Forêt\", layer.name = \"% foret\")\n\n\n\n\nbuffer_landcover_terra$area_ha &lt;- expanse(buffer_landcover_terra) * 0.0001\n\nocc &lt;- tapply(\n  buffer_landcover_terra$area_ha,\n  list(buffer_landcover_terra$X, buffer_landcover_terra$nature),\n  sum\n)\n#replace NA by 0\nocc[is.na(occ)] &lt;- 0\n# calculate the overlay area\nsum_occ &lt;- rowSums(occ)\n# calculate the percentage per class\nperc_occ &lt;- occ / sum_occ * 100\n\nbarplot(t(perc_occ))\n\n\n\n\n\n\n\n# add information in the spatial vector\npt_otter_terra &lt;- cbind(pt_otter_terra, perc_occ)\nmapview(pt_otter_terra, z = \"Forêt\", layer.name = \"% foret\")",
    "crumbs": [
      "Vectors",
      "Polygons"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html",
    "href": "chapters/21_rasters.html",
    "title": "Rasters",
    "section": "",
    "text": "Introduction\nAt the end of this tutorial, you will be know :\nRaster spatial data are also called gridded dataset, or matrices.\nThe most commun file types are: addrefslide\n- GeoTIFF (.tif) - netCDF (.nc), … - ASCII Grid (.asc)\nFor working with rasters, the recommended R-package is terra.",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#setup",
    "href": "chapters/21_rasters.html#setup",
    "title": "Rasters",
    "section": "Setup",
    "text": "Setup\n\n\nFollow the setup instructions if you haven’t followed the tutorial on points\n\nIf haven’t done it already, please follow the setup instructions. Let’s start with loading the required packages.\n\nsuppressPackageStartupMessages({\n  library(mapview)\n  library(here)\n  library(sf)\n  library(terra)\n  library(exactextractr)\n})\n\n\nlocalonline\n\n\n\npt_otter &lt;- vect(here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\n\n\n\n\npt_otter &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.gpkg\"\n)",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#load-raster-from-a-geotiff-file",
    "href": "chapters/21_rasters.html#load-raster-from-a-geotiff-file",
    "title": "Rasters",
    "section": "Load raster from a geotiff file",
    "text": "Load raster from a geotiff file\nFor this example, we will load the elevation data for the area of interest from IGN data BD ALTI which was aggregated at 250m resolution (instead of its original resolution of 25m). Note that the rough resolution of this dataset is perfect for our learning purpose. Yet for real analyses, you might want to consider finer spatial data.\n\nlocalonline\n\n\n\nbdalti &lt;- rast(here(\"data\", \"BDALTI_mpl50km.tif\"))\n\n\n\n\nbdalti &lt;- rast(\n  \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDALTI_mpl50km.tif\"\n)",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#handling-rasters",
    "href": "chapters/21_rasters.html#handling-rasters",
    "title": "Rasters",
    "section": "Handling rasters",
    "text": "Handling rasters\n\nbdalti\n\nclass       : SpatRaster \nsize        : 432, 439, 1  (nrow, ncol, nlyr)\nresolution  : 250, 250  (x, y)\nextent      : 715438.3, 825188.3, 6233959, 6341959  (xmin, xmax, ymin, ymax)\ncoord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154) \nsource      : BDALTI_mpl50km.tif \nname        : BDALTI_mpl50km \n\n# get the dimension: dim()\ndim(bdalti) # number of x, y and z dimensions\n\n[1] 432 439   1\n\n# check the projection system : crs()\ncrs(bdalti, describe = TRUE)\n\n                   name authority code\n1 RGF93 v1 / Lambert-93      EPSG 2154\n                                                                                           area\n1 France - onshore and offshore, mainland and Corsica (France métropolitaine including Corsica)\n                      extent\n1 -9.86, 10.38, 41.15, 51.56\n\n# get the extent : ext()\next(bdalti)\n\nSpatExtent : 715438.281255682, 825188.281255682, 6233958.55620402, 6341958.55620402 (xmin, xmax, ymin, ymax)\n\n# get the name of the layer\nnames(bdalti)\n\n[1] \"BDALTI_mpl50km\"\n\n# rename the layer (for simplicity)\nnames(bdalti) &lt;- \"elevation\"\n\n# get all the values : values()\n# use only for small raster, else it takes large amount of time and memory\nboxplot(values(bdalti), ylab = \"elevation (m)\")\n\n\n\n\n\n\n\n# mean elevation in our study area\nmean(values(bdalti))\n\n[1] 198.9497",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#visualization",
    "href": "chapters/21_rasters.html#visualization",
    "title": "Rasters",
    "section": "Visualization",
    "text": "Visualization\n\ninteractivestatic\n\n\n\nmapview(bdalti)\n\n\n\n\n\n\n\n\nplot(bdalti)\n\n\n\n\n\n\n\n\n\n\n\n\nSet NA values\nLet’s imagine we want to remove the sea and all values below 0\nor should we mask?\n\n# make sure values are between 0 and 2000 m\nalti &lt;- clamp(bdalti, 0, 2000, values = TRUE)\n# set values with elevation 0 as NA (remove the sea)\nNAflag(alti) &lt;- 0\nplot(alti)\n\n\n\n\n\n\n\n# mean elevation in our study area (excluding sea)\nmean(values(alti), na.rm = TRUE)\n\n[1] 252.6259",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#points-to-raster",
    "href": "chapters/21_rasters.html#points-to-raster",
    "title": "Rasters",
    "section": "Points to raster",
    "text": "Points to raster\nExample with numerical values\n\ncrs(bdalti) == crs(pt_otter)\n\n[1] FALSE\n\n\nIn this case, the projection are not the same. It is recommended to project the points instead of the raster (much faster).\n\npt_2154 &lt;- project(pt_otter, crs(bdalti))\n\n\nplot(bdalti, \"elevation\")\nplot(pt_2154, add = TRUE, col = \"red\")\n\n\n\n\n\n\n\n\n\npt_alti &lt;- extract(bdalti, pt_2154)\n\n\nboxplot(pt_alti$elevation, ylab = \"elevation (m)\")\n\n\n\n\n\n\n\n\nExtra: compare with data from GBIF\n\n# check with recorded\nplot(\n  pt_alti$elevation,\n  pt_otter$elevation,\n  xlab = \"elevation (m) GBIF values\",\n  ylab = \"elevation (m) BDALTI values\",\n  asp = 1\n)\n# add identity line\nabline(a = 0, b = 1)",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#polygons-to-raster",
    "href": "chapters/21_rasters.html#polygons-to-raster",
    "title": "Rasters",
    "section": "Polygons to raster",
    "text": "Polygons to raster",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/21_rasters.html#polygons-to-raster-1",
    "href": "chapters/21_rasters.html#polygons-to-raster-1",
    "title": "Rasters",
    "section": "Polygons to raster",
    "text": "Polygons to raster\nexample with buffer from points zonal could be faster? and mention exactextractr package which is much faster for large dataset.\n\nCreate buffer\n\npoly_otter &lt;- buffer(pt_2154, 1000)\n\n\n\nGet average elevation\n\nmean_alti &lt;- extract(bdalti, poly_otter, fun = mean)\n\nplot(mean_alti$elevation, pt_alti$elevation)\n\n\n\n\n\n\n\n\n\n\nGet variation of elevation\n\nsd_alti &lt;- extract(bdalti, poly_otter, fun = sd)\n\nplot(sd_alti$elevation, pt_alti$elevation)\n\n\n\n\n\n\n\n\nExtra: is variation linked to average slope?\n\n\nGet all values\n\nfull_alti &lt;- extract(bdalti, poly_otter)\n\n# number of pixel per buffer (around 50)\ntable(table(full_alti$ID))\n\n\n47 48 49 50 51 52 \n 1  3  6 49 12 12 \n\nmed_otter &lt;- tapply(full_alti$elevation, full_alti$ID, median)",
    "crumbs": [
      "Rasters",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/22_multilayer.html",
    "href": "chapters/22_multilayer.html",
    "title": "Multi-layer rasters",
    "section": "",
    "text": "File format\nAt the end of this tutorial, you will be know how to:\nYou could get anything among netCDF, grid, tif. All can be read with terra::rast()",
    "crumbs": [
      "Rasters",
      "Multi-layer rasters"
    ]
  },
  {
    "objectID": "chapters/22_multilayer.html#setup",
    "href": "chapters/22_multilayer.html#setup",
    "title": "Multi-layer rasters",
    "section": "Setup",
    "text": "Setup\n\n\nFollow the setup instructions if you haven’t followed previous tutorials\n\nIf haven’t done it already, please follow the setup instructions.\nLet’s start with loading the required packages.\n\nsuppressPackageStartupMessages({\n  library(mapview)\n  library(here)\n  library(sf)\n  library(terra)\n  library(exactextractr)\n})\n\nAnd the needed dataset (observations of otter in 2021 around Montpellier, France).\n\nlocalonline\n\n\n\npt_otter &lt;- vect(here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\n\n\n\n\npt_otter &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.gpkg\"\n)",
    "crumbs": [
      "Rasters",
      "Multi-layer rasters"
    ]
  },
  {
    "objectID": "chapters/22_multilayer.html#monthly-climate-with-chelsa",
    "href": "chapters/22_multilayer.html#monthly-climate-with-chelsa",
    "title": "Multi-layer rasters",
    "section": "Monthly climate with CHELSA",
    "text": "Monthly climate with CHELSA\n\nmeantemp &lt;- rast(here(\"data\", \"CHELSA_monthly_tas_2015_2021.tif\"))\nmeantemp\n\nclass       : SpatRaster \nsize        : 116, 165, 84  (nrow, ncol, nlyr)\nresolution  : 0.008333333, 0.008333333  (x, y)\nextent      : 3.191527, 4.566527, 43.19986, 44.16653  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : CHELSA_monthly_tas_2015_2021.tif \nnames       : CHELS~V.2.1, CHELS~V.2.1, CHELS~V.2.1, CHELS~V.2.1, CHELS~V.2.1, CHELS~V.2.1, ... \nmin values  :       273.4,       271.5,       275.9,       278.8,       282.9,       287.1, ... \nmax values  :       283.8,       282.4,       285.5,       288.5,       293.3,       297.6, ... \n\n# shorten names\ntime_chelsa &lt;- substr(names(meantemp), 12, 18)\nnames(meantemp) &lt;- time_chelsa\n\n\npt_temp &lt;- extract(meantemp, pt_otter, ID = FALSE)\nsummary(unlist(pt_temp))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  274.1   282.7   286.9   287.8   293.7   300.1 \n\n\n\n# transform to degree celsius\npt_tempC &lt;- pt_temp - 273.15\n\n# plot\nboxplot(pt_tempC, las = 2, ylab = \"Temperature (*C)\")\n\n\n\n\n\n\n\n\n\nmean_temp &lt;- apply(pt_tempC, 1, mean, na.rm = TRUE)\nsummary(mean_temp)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  10.74   14.04   14.74   14.69   15.76   16.31 \n\npt_otter$mean_temp &lt;- mean_temp\nplot(pt_otter, \"mean_temp\")\n\n\n\n\n\n\n\n\n\ncv_temp &lt;- apply(pt_tempC, 1, sd, na.rm = TRUE) / mean_temp\nsummary(cv_temp)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.3334  0.3823  0.4326  0.4185  0.4445  0.5517 \n\npt_otter$cv_temp &lt;- cv_temp\nplot(pt_otter, \"cv_temp\")\n\n\n\n\n\n\n\n\n\n# too old school\n# pt_otter$month2 &lt;- ifelse(pt_otter$month&lt;10, paste0(\"0\",pt_otter$month), pt_otter$month)\n# pt_otter$time &lt;- paste(pt_otter$month2, pt_otter$year, sep=\"_\")\n# better :\npt_otter$time &lt;- as.Date(pt_otter$eventDate) |&gt; format(\"%m_%Y\")\n\ntable(pt_otter$time)\n\n\n01_2021 02_2021 03_2021 04_2021 05_2021 06_2021 07_2021 08_2021 09_2021 10_2021 \n     12      11      11       8       3       6       4       3       6       7 \n11_2021 12_2021 \n      5       7 \n\n# get temperature at the month of observation\nxy &lt;- cbind(1:nrow(pt_otter), match(pt_otter$time, names(pt_tempC)))\npt_otter$temp_obs &lt;- pt_tempC[xy]\nsummary(pt_otter$temp_obs)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   4.55    7.75   10.35   12.44   15.75   23.85 \n\nplot(pt_otter, \"temp_obs\")",
    "crumbs": [
      "Rasters",
      "Multi-layer rasters"
    ]
  },
  {
    "objectID": "chapters/31_toydata_mpl.html",
    "href": "chapters/31_toydata_mpl.html",
    "title": "Create a toy dataset from GBIF and IGN data",
    "section": "",
    "text": "1. Set the spatial extent\nThis is a small practical example on how get data from GBIF and IGN based on a geographical area. For this tutorial, we will need sf, mapview, happign, and rgbif packages.\nFor this example, we will focus on an area around FRB-CESAB in Montpellier. So we will need to\n(1) find the coordinates of FRB-CESAB (2) create a buffer area",
    "crumbs": [
      "Extra",
      "Create a toy dataset from GBIF and IGN data"
    ]
  },
  {
    "objectID": "chapters/31_toydata_mpl.html#set-the-spatial-extent",
    "href": "chapters/31_toydata_mpl.html#set-the-spatial-extent",
    "title": "Create a toy dataset from GBIF and IGN data",
    "section": "",
    "text": "Get coordinates from an address\nThis task is called geocoding. Among other resource, we recommend the package rgeoservices (if in France, based on french IGN services) or the package tidygeocoder using Open Street Map data.\n\nrgeoservicestidygeocodermanual\n\n\n\n#|\ncesab &lt;- rgeoservices::gs_get_coordinates(\n  query = \"5 rue de l’École de médecine, 34000 MONTPELLIER\",\n  index = \"address\"\n)\n\n\n\n\n#|\ncesab &lt;- tidygeocoder::geocode(\n  data.frame(x = \"5 rue de l’École de médecine, 34000 MONTPELLIER\"),\n  address = \"x\",\n  method = \"osm\"\n)\n# for compatibility with other solutions, rename the columns\nnames(cesab) &lt;- c(\"x\", \"latitude\", \"longitude\")\n\n\n\n\n# for such a simple case, it's easier to get coordinates from GoogleMap\n# https://maps.app.goo.gl/woqBZSs63zSjHUsS9\ncesab &lt;- data.frame(\n  \"latitude\" = 43.61269208391402,\n  \"longitude\" = 3.8733758693843585\n)\n\n\n\n\n\n\nCreate a spatial object from coordinates\nWe will use the function sf::st_as_sf() with the names of the columns for the longitude (x), the latitude (y) and the Coordinate Reference System (CRS) which is EPSG:4326.\n\n# create st_point\npt_cesab &lt;- st_as_sf(\n  cesab,\n  coords = c(\"longitude\", \"latitude\"),\n  crs = 4326\n)\n\n\n\nCreate a buffer from points\nWe want a buffer zone of 50km around the FRB-Cesab. Because GBIF only accept rectangle buffer, we will take the square that include the circular buffer.\n\nbuffer_size &lt;- 50000 # in m because data are in EPSG 4326\n\n# create a round buffer zone\nb_circle &lt;- st_buffer(pt_cesab, buffer_size)\n\n# transform to square because occ_search() needs rectangle\nb_square &lt;- st_bbox(b_circle) |&gt; st_as_sfc()\n\nWe can visualize the spatial data created with mapview:\n\nmapview(b_square, alpha.regions = 0, lwd = 3) +\n  mapview(b_circle, alpha.regions = 0.1, lwd = 0) +\n  mapview(pt_cesab)",
    "crumbs": [
      "Extra",
      "Create a toy dataset from GBIF and IGN data"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Appelhans, Tim, Florian Detsch, Christoph Reudenbach, and Stefan\nWoellauer. 2025. Mapview: Interactive Viewing of Spatial Data in\nr. https://doi.org/10.32614/CRAN.package.mapview.\n\n\nHijmans, Robert J. 2025. Terra: Spatial Data Analysis. https://doi.org/10.32614/CRAN.package.terra.\n\n\nPebesma, Edzer. 2018. “Simple Features for r: Standardized Support\nfor Spatial Vector Data.” The R Journal 10\n(1): 439–46. https://doi.org/10.32614/RJ-2018-009.",
    "crumbs": [
      "References"
    ]
  }
]