[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spatial-r: Tutorials on spatial data analysis in R",
    "section": "",
    "text": "Preface\nThis is a collection of tutorials on how to handle spatial data in R.\nIt is made for a two half-day workshop, but you can follow the tutorials on your own pace.\nThe aims of this workshop is to :\n\nFeel more comfortable to work with spatial data\nLoad spatial data in R and visualize it\nExtract information from remote sensing or other fields\nTake advantage of the numerous databases that are available online\n\nThe tutorial targets students and scientists in ecology with previous knowledge of the R software.\n\nR package\nThe tutorials will mostly rely on (terra R-package)[] for most of the spatial data handling.\nR is exceptional due to its diversity, and their exist other package to handle spatial data, sf and stars being also very good resources.\n\n\nKey resources\nThese tutorials has been inspired by brilliant resources online:\n\nHijman R. et al. Spatial Data Science with R and “terra”\n\nPebesma and Bivand Spatial Data Science: With Applications in R\nMoraga P. (2023)Spatial Statistics for Data Science: Theory and Practice with R\nLovelace, Nowosad, and Muenchow (2025) Book on geographic data with R\n\n\n\nPreliminary program\nDay 1\n- lesson1 : INTRODUCTION GIS, vector vs raster view, projection system (CRS)\n- tuto1 : VECTOR: create points and polygons; map and project spatial objects, calculate distance and areas\n- tuto2 : RASTER: load and download rasters, change their resolutions, map etc\n- tuto3 : EXTRACT: how to mix them: raster and points, raster and buffer, raster and polygons, projection raster&gt;polygon\nDay 2\n- lesson2 : INTRODUCTION GIS, vector vs raster view, projection system (CRS)\n- tuto4 : STACK: how to load and manipulate multilayer rasters (e.g. remote sensing), thresholding multi day, and multi spectral\n- tuto5 : COMBINE MULTI-SOURCE DATA - reprojecting rasters, tips and tricks\n- tuto6 : INTERACTIVE maps with leaflet, mapview, or tmap\nExtra:\n- tutoE1 : POLYGON: calculate convex hull, simplify geometries, aggregate, union, etc… spatial influence\n- tutoE2 : get data from WMS or WFS\n- tutoE3 : spatial autocorrelation - how to measure it, what to do about it? spatial regression model, local regression\n- tutoE4 : Krigging and interpolation\n- tutoE5 : remote sensing, landsat and modis\n- tutoE6 : GoogleEarthEngine, what it is and how to use it (mostly out of R)",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "chapters/01_intro.html",
    "href": "chapters/01_intro.html",
    "title": "Introduction",
    "section": "",
    "text": "How to install R and set up environment\n\n\nR packages needed for these tutorials\nWe will mostly use terra and mapview as a starter. Fancier maps can be created with mapsf and tmap (ref tutorials)\n\n\nDownload needed dataset\n\n# set data directory\ndatadir &lt;- here::here(\"data\")\nif (!dir.exists(datadir)) {\n  dir.create(\n    path = datadir,\n    showWarnings = FALSE,\n    recursive = TRUE\n  )\n}\n\nurl_git &lt;- \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data\"\n\n# download GBIF data\nfile1 &lt;- \"gbif_otter_2021_mpl50km.csv\"\ndownload.file(file.path(url_git, file1), file.path(datadir, file1), mode = \"wb\")\n\n# download elevation data\nfile2 &lt;- \"BDALTI_mpl50km.tif\"\ndownload.file(file.path(url_git, file2), file.path(datadir, file2), mode = \"wb\")\n\n# download administrative borders\nfile3 &lt;- \"BDCARTO-Commune_mpl50km.gpkg\"\ndownload.file(file.path(url_git, file3), file.path(datadir, file3), mode = \"wb\")\n\n# download rivers\nfile4 &lt;- \"BDCARTO-River_mpl50km.gpkg\"\ndownload.file(file.path(url_git, file4), file.path(datadir, file4), mode = \"wb\")\n\n# download land cover\nfile5 &lt;- \"BDCARTO-LULC_mpl50km\"\nshpext &lt;- c(\"dbf\", \"prj\", \"shp\", \"shx\")\nurl_shp &lt;- file.path(url_git, paste(file5, shpext, sep = \".\"))\ndir_shp &lt;- file.path(datadir, paste(file5, shpext, sep = \".\"))\nfor (i in seq_along(shpext)) {\n  download.file(url_shp[i], dir_shp[i], mode = \"wb\")\n}",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "chapters/11_presentation.html",
    "href": "chapters/11_presentation.html",
    "title": "Spatial data",
    "section": "",
    "text": "NoteAn introduction to spatial data\n\n\n\n   Source: https://github.com/FRBCesab/spatial-slides   Slides: https://frbcesab.github.io/spatial-slides/env-data",
    "crumbs": [
      "Day 1",
      "Spatial data"
    ]
  },
  {
    "objectID": "chapters/12_vectors.html",
    "href": "chapters/12_vectors.html",
    "title": "Vectors",
    "section": "",
    "text": "Introduction\nAt the end of this tutorial, you will be know :\nTypically, there are three types of vectors: addrefslide\nThe most common formats are: addrefslide\nThere are two main packages in R to work with spatial vectors: terra and sf (that replace older packages such as raster and sp). This tutorial will mostly use the package terra for smoother integration with the rest of the tutorial (especially working with rasters), but most functions have their equivalent in sf.\nAt the start of the tutorial, equivalent functions in sf will be shown.\nLet’s start with loading the required packages.\nlibrary(terra) |&gt; suppressPackageStartupMessages()\nlibrary(mapview)\nlibrary(here) |&gt; suppressPackageStartupMessages()\nlibrary(sf) |&gt; suppressPackageStartupMessages()",
    "crumbs": [
      "Day 1",
      "Vectors"
    ]
  },
  {
    "objectID": "chapters/12_vectors.html#introduction",
    "href": "chapters/12_vectors.html#introduction",
    "title": "Vectors",
    "section": "",
    "text": "Points\nLines\nPolygons\n\n\n\nESRI shapefile (.shp) : the traditional and most frequently used format\nGeopackages (.gpkg) : the new standard\nGPS Exchange Format (.gpx)\nGoogle Earth file (.kml / .kmz)",
    "crumbs": [
      "Day 1",
      "Vectors"
    ]
  },
  {
    "objectID": "chapters/12_vectors.html#points",
    "href": "chapters/12_vectors.html#points",
    "title": "Vectors",
    "section": "Points",
    "text": "Points\n\nCreating spatial points from data\nThis is the most common case: you have coordinates from a (csv/excel/text) file and you want to get spatial information about these locations. The first step is to transform the coordinates as proper spatial object in R.\nWe will use a dataset from GBIF(addref) with all occurrences of otter recorded in 2021 within a 50km buffer from Montpellier, France. This data was prepared and stored on Github.\n\nlocalonline\n\n\n\notter &lt;- read.csv(here(\"data\", \"gbif_otter_2021_mpl50km.csv\"))\n\n\n\n\notter &lt;- read.csv(\n  \"https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.csv\"\n)\n\n\n\n\n\ndim(otter)\n\n[1] 83 15\n\nnames(otter)\n\n [1] \"key\"                              \"institutionCode\"                 \n [3] \"species\"                          \"occurrenceStatus\"                \n [5] \"eventDate\"                        \"year\"                            \n [7] \"month\"                            \"day\"                             \n [9] \"decimalLongitude\"                 \"decimalLatitude\"                 \n[11] \"elevation\"                        \"identificationVerificationStatus\"\n[13] \"identifier\"                       \"datasetKey\"                      \n[15] \"provider\"                        \n\ntable(otter$institutionCode)\n\n\n iNaturalist UAR PatriNat \n           7           76 \n\n\nThe dataset contains 83 observations of otter (in rows), and 15 variables (in column) such as date, coordinates, and data provider. The geographic coordinates are stored in the columns decimalLongitude, and decimalLatitude. They are expressed in decimal degrees, with the standard datum WGS84 EPSG:4326.\nLet’s create a spatial object from the coordinates.\n\nterrasf\n\n\nIn terra, the key function is terra::vect().\n\npt_terra &lt;- vect(\n  otter,\n  geom = c(\"decimalLongitude\", \"decimalLatitude\"),\n  crs = \"EPSG:4326\"\n)\n# summary\npt_terra\n\n class       : SpatVector \n geometry    : points \n dimensions  : 83, 13  (geometries, attributes)\n extent      : 3.28983, 4.46447, 43.30373, 44.06548  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :       key institutionCode     species occurrenceStatus\n type        :     &lt;num&gt;           &lt;chr&gt;       &lt;chr&gt;            &lt;chr&gt;\n values      : 3.059e+09     iNaturalist Lutra lutra          PRESENT\n               3.854e+09    UAR PatriNat Lutra lutra          PRESENT\n               3.854e+09    UAR PatriNat Lutra lutra          PRESENT\n       eventDate  year month   day elevation identificationVerificationStatus\n           &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;                            &lt;chr&gt;\n 2021-01-24T15:~  2021     1    24        NA                               NA\n      2021-01-13  2021     1    13        NA                         Probable\n      2021-01-08  2021     1     8        NA                         Probable\n (and 3 more)\n             \n             \n             \n             \n\n# visualization\nplot(pt_terra)\n\n\n\n\n\n\n\n\n\n\nIn sf, the key function is sf::st_as_sf().\n\npt_sf &lt;- st_as_sf(\n  otter,\n  coords = c(\"decimalLongitude\", \"decimalLatitude\"),\n  crs = \"EPSG:4326\"\n)\n# summary\npt_sf\n\nSimple feature collection with 83 features and 13 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3.28983 ymin: 43.30373 xmax: 4.46447 ymax: 44.06548\nGeodetic CRS:  WGS 84\nFirst 10 features:\n          key institutionCode     species occurrenceStatus           eventDate\n1  3058935748     iNaturalist Lutra lutra          PRESENT 2021-01-24T15:26:55\n2  3853886594    UAR PatriNat Lutra lutra          PRESENT          2021-01-13\n3  3853886619    UAR PatriNat Lutra lutra          PRESENT          2021-01-08\n4  3853886780    UAR PatriNat Lutra lutra          PRESENT          2021-01-12\n5  4546764953    UAR PatriNat Lutra lutra          PRESENT          2021-01-31\n6  4546968119    UAR PatriNat Lutra lutra          PRESENT          2021-01-17\n7  4547054813    UAR PatriNat Lutra lutra          PRESENT          2021-01-31\n8  4548321676    UAR PatriNat Lutra lutra          PRESENT          2021-01-23\n9  4548484387    UAR PatriNat Lutra lutra          PRESENT          2021-01-31\n10 4552966259    UAR PatriNat Lutra lutra          PRESENT          2021-01-06\n   year month day elevation identificationVerificationStatus\n1  2021     1  24        NA                             &lt;NA&gt;\n2  2021     1  13        NA                         Probable\n3  2021     1   8        NA                         Probable\n4  2021     1  12        NA                         Probable\n5  2021     1  31        NA                         Probable\n6  2021     1  17        NA                         Probable\n7  2021     1  31        NA                         Probable\n8  2021     1  23        NA                         Probable\n9  2021     1  31        NA                         Probable\n10 2021     1   6        NA                         Probable\n                             identifier                           datasetKey\n1                              68608477 50c9509d-22c7-4a22-a47d-8c48425ef4a7\n2  5b4c3803-50a9-465a-a1a7-35c4a4d7d508 c32f3129-a4dc-4e36-86d4-a35cc5cfb04d\n3  cc533347-f1e3-4cf3-9f55-2c7cf60500de c32f3129-a4dc-4e36-86d4-a35cc5cfb04d\n4  3210c6f2-391a-4cc4-b497-b915bbc9d7d4 c32f3129-a4dc-4e36-86d4-a35cc5cfb04d\n5  631348e0-646f-41eb-b3c7-01900054c689 256b9877-cef3-4e8e-84e1-f23299c49655\n6  754868ad-58ef-41eb-b3c7-01900054452d 256b9877-cef3-4e8e-84e1-f23299c49655\n7  771217f4-6470-41eb-b3c7-01900054c695 256b9877-cef3-4e8e-84e1-f23299c49655\n8  b00a76e4-907d-41eb-adf1-041006068357 256b9877-cef3-4e8e-84e1-f23299c49655\n9  b2343db5-646f-41eb-b3c7-01900054c693 256b9877-cef3-4e8e-84e1-f23299c49655\n10 33310104-5041-41eb-bfb5-01900053f23b 256b9877-cef3-4e8e-84e1-f23299c49655\n                                                                                 provider\n1                                                 iNaturalist Research-grade Observations\n2  LIGNE NOUVELLE MONTPELLIER PERPIGNAN DUP PHASE 1 - Inventaire non protocolé Mammifères\n3  LIGNE NOUVELLE MONTPELLIER PERPIGNAN DUP PHASE 1 - Inventaire non protocolé Mammifères\n4  LIGNE NOUVELLE MONTPELLIER PERPIGNAN DUP PHASE 1 - Inventaire non protocolé Mammifères\n5                                          UAR PatriNat - opportunistic data Faune-France\n6                                          UAR PatriNat - opportunistic data Faune-France\n7                                          UAR PatriNat - opportunistic data Faune-France\n8                                          UAR PatriNat - opportunistic data Faune-France\n9                                          UAR PatriNat - opportunistic data Faune-France\n10                                         UAR PatriNat - opportunistic data Faune-France\n                    geometry\n1  POINT (3.792841 43.81636)\n2   POINT (3.46399 43.38562)\n3    POINT (3.28983 43.3172)\n4   POINT (3.83235 43.57202)\n5   POINT (3.46399 43.38562)\n6   POINT (3.92099 44.06548)\n7   POINT (3.85823 43.52581)\n8   POINT (3.57398 43.63949)\n9    POINT (3.28983 43.3172)\n10  POINT (3.54517 43.75695)\n\n# visualization\nplot(pt_sf, max.plot = 1, axes = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\nHandling spatial vectors\nLet’s have a look at the most common functions to handle spatial vectors in R.\n\nterrasf\n\n\n\n# get the geographical extent\next(pt_terra)\n\nSpatExtent : 3.28983, 4.46447, 43.30373, 44.06548 (xmin, xmax, ymin, ymax)\n\n# get number of objects, number of attributes\ndim(pt_terra)\n\n[1] 83 13\n\n# get the projection system\ncrs(pt_terra, describe = TRUE)\n\n    name authority code  area             extent\n1 WGS 84      EPSG 4326 World -180, 180, -90, 90\n\n# get the coordinates\ncrds(pt_terra) |&gt; head()\n\n            x        y\n[1,] 3.792841 43.81636\n[2,] 3.463990 43.38562\n[3,] 3.289830 43.31720\n[4,] 3.832350 43.57202\n[5,] 3.463990 43.38562\n[6,] 3.920990 44.06548\n\n# manipulate the dataset\n# the attached data is formatted as a standard data.frame\n# you can add a new column with '$' (for instance month labels)\npt_terra$lab_month &lt;- month.name[pt_terra$month]\n\n# filter rows with '[]' (for instance, keep only iNaturalist observations)\niNat_terra &lt;- pt_terra[pt_terra$institutionCode == \"iNaturalist\", ]\ndim(iNat_terra)\n\n[1]  7 14\n\n\n\n\n\n# get the geographical extent\nst_bbox(pt_sf)\n\n    xmin     ymin     xmax     ymax \n 3.28983 43.30373  4.46447 44.06548 \n\n# get number of objects, number of attributes\ndim(pt_sf)\n\n[1] 83 14\n\n# get the projection system\ncrs(pt_sf, describe = TRUE)\n\n    name authority code  area             extent\n1 WGS 84      EPSG 4326 World -180, 180, -90, 90\n\n# get the coordinates\nst_coordinates(pt_sf) |&gt; head()\n\n            X        Y\n[1,] 3.792841 43.81636\n[2,] 3.463990 43.38562\n[3,] 3.289830 43.31720\n[4,] 3.832350 43.57202\n[5,] 3.463990 43.38562\n[6,] 3.920990 44.06548\n\n# manipulate the dataset\n# the attached data is formatted as a standard data.frame\n# you can add a new column with '$' (for instance month labels)\npt_sf$lab_month &lt;- month.name[pt_sf$month]\n\n# filter rows with '[]' (for instance, keep only iNaturalist observations)\niNat_sf &lt;- pt_sf[pt_sf$institutionCode == \"iNaturalist\", ]\ndim(iNat_sf)\n\n[1]  7 15\n\n\n\n\n\n\n\nProjection\nThere are different coordinate reference systems in which coordinates can be expressed (e.g. different unit). While manipulating multiple datasets from different sources, it is important to make sure they are all in the same coordinate system. If it is not the case, then you will need make projection to convert the projection system. addrefslide\nFor example, in France, the preferred projection system by IGN is Lambert 93 (EPSG:2154).As an exercise, let’s project our points to EPSG:2154.\n\nterrasf\n\n\nIn terra, the key function is terra::project().\n\n# projection\npt_2154_terra &lt;- project(pt_terra, \"EPSG:2154\")\n# see the differences in the bounding box\n# extent in lat/long\next(pt_terra)\n\nSpatExtent : 3.28983, 4.46447, 43.30373, 44.06548 (xmin, xmax, ymin, ymax)\n\n# new extent in Lambert-93\next(pt_2154_terra)\n\nSpatExtent : 723524.638618867, 818474.392571545, 6245000.52485334, 6330038.9258292 (xmin, xmax, ymin, ymax)\n\n\n\n\nIn sf, the key function is sf::st_transform().\n\n#projection\npt_2154_sf &lt;- st_transform(pt_sf, crs = \"EPSG:2154\")\n# see the differences in the bounding box\n# extent in lat/long\nst_bbox(pt_sf)\n\n    xmin     ymin     xmax     ymax \n 3.28983 43.30373  4.46447 44.06548 \n\n# new extent in Lambert-93\nst_bbox(pt_2154_sf)\n\n     xmin      ymin      xmax      ymax \n 723524.6 6245000.5  818474.4 6330038.9 \n\n\n\n\n\n\n\nExport the data\nFor vectors, it is recommended to export them as geopackage file (extension .gpkg). Compare to traditional ESRI shapefile, the geopackage format store the data in a single file and the column names are preserved. (addref slide file format).\n\nterrasf\n\n\nIn terra, the function is terra::writeVector().\n\nwriteVector(pt_terra, here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\n\n\n\nIn sf, the function is sf::write_sf().\n\nwrite_sf(pt_sf, here(\"data\", \"gbif_otter_2021_mpl50km.gpkg\"))\n\n\n\n\n\n\nConversion between sf and terra\nIt is confusing to have two dominant packages terra and sf having similar functionalities. Luckily, the conversion between these two format is easy.\n\nfrom terra to spfrom sf to terra\n\n\nTo convert a terra vector into sf, the function is sf::st_as_sf().\n\npt_sf &lt;- st_as_sf(pt_terra)\n\n\n\nTo convert a sf feature into terra, the function is terra::vect(). Be careful that non-homogeneous features (mix of points, lines and polygons) can’t be converted as a terra SpatVector object. Only homogeneous points, line or polygons can be converted into terra geometry.\n\npt_terra &lt;- vect(pt_sf)",
    "crumbs": [
      "Day 1",
      "Vectors"
    ]
  },
  {
    "objectID": "chapters/12_vectors.html#lines",
    "href": "chapters/12_vectors.html#lines",
    "title": "Vectors",
    "section": "Lines",
    "text": "Lines\nLines are another type of vectors, made of multiple points. It is possible to create lines but in practice, it often comes from an existing spatial dataset. In our example case study, we will load the rivers for the area of interest from BD CARTO (addref).\n\nLoad lines from a geopackage file\n\nlocalonline\n\n\n\nriver &lt;- vect(here(\"data\", \"BDCARTO-River_mpl50km.gpkg\"))\n\n\n\n\nriver &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-River_mpl50km.gpkg\"\n)\n\n\n\n\n\n\nHandling spatial vectors\n\n# get the number of objects, and the number of attributes\ndim(river)\n\n[1] 1500    8\n\n# get the projection system\ncrs(river, describe = TRUE)\n\n    name authority code  area             extent\n1 WGS 84      EPSG 4326 World -180, 180, -90, 90\n\n# see a subset of the data\nhead(river, 3)\n\n              id                   cleabs code_hydrographique statut\n1 cours_d_eau.46 COURDEAU0000002276554466 06C0000002276554466 Validé\n2 cours_d_eau.52 COURDEAU0000002215481117 06C0000002215481117 Validé\n3 cours_d_eau.59 COURDEAU0000002000818257 06C0000002000818257 Validé\n                 toponyme statut_du_toponyme influence_de_la_maree\n1              la Dourbie             Validé                  &lt;NA&gt;\n2 Ruisseau de Montmorency             Validé                  &lt;NA&gt;\n3      Ruisseau de Lussac             Validé                  &lt;NA&gt;\n  caractere_permanent\n1                &lt;NA&gt;\n2                &lt;NA&gt;\n3                &lt;NA&gt;\n\n\n\n\nCalculate length of lines\nThe function terra::perim() calculate the length of lines (expressed in meter). While calculating distance and length, be careful with projection systems. Some are not suited to calculate distance. Prefer equidistant projections or use local projection system (if your study area is small). The package terra recommends the calculation of distances in lat/long to get more accurate results (considering the geodesic distance, so accounting for Earth’s curvature). (addrefslide)\n\n# calculate the length of rivers\nriver$length_km &lt;- perim(river) / 1000\n\n# see the distribution of river length\nboxplot(river$length_km, ylab = \"length (km)\")\n\n\n\n\n\n\n\n# get the name of the longest river\nriver$toponyme[which.max(river$length_km)]\n\n[1] \"l'Hérault\"\n\n\n\n\nVisualization\n\ninteractivestatic\n\n\n\nmapview(river, z = \"length_km\") +\n  mapview(pt_terra, col.regions = \"red\", color = NA)\n\n\n\n\n\n\n\n\nplot(river, y = \"length_km\", type = \"continuous\")\nplot(pt_terra, col = \"red\", add = TRUE)",
    "crumbs": [
      "Day 1",
      "Vectors"
    ]
  },
  {
    "objectID": "chapters/12_vectors.html#polygons",
    "href": "chapters/12_vectors.html#polygons",
    "title": "Vectors",
    "section": "Polygons",
    "text": "Polygons\n\nLoad polygons from a shapefile\n\nlocalonline\n\n\n\nlanduse &lt;- vect(here(\"data\", \"BDCARTO-LULC_mpl50km.shp\"))\n\n\n\n\nlanduse &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-LULC_mpl50km.shp\"\n)\n\n\n\n\n\n\nHandling spatial vectors\n\n# get the number of objects, and the number of attributes\ndim(landuse)\n\n[1] 2384    3\n\n# get the projection system\ncrs(landuse, describe = TRUE)\n\n    name authority code area         extent\n1 WGS 84      EPSG 4326 &lt;NA&gt; NA, NA, NA, NA\n\n# see a subset of the data\nhead(landuse, 3)\n\n                    id                   cleabs       nature\n1 occupation_du_sol.32 BDC_OCS_0000002201861697 Broussailles\n2 occupation_du_sol.68 BDC_OCS_0000002201863362         Bâti\n3 occupation_du_sol.98 BDC_OCS_0000002201860189    Eau libre\n\n# see the distribution of land cover classes (number of polygons)\ntable(landuse$nature)\n\n\n              Bâti       Broussailles Carrière, décharge          Eau libre \n               360                235                 35                 49 \n             Forêt      Marais salant  Marais, tourbière            Prairie \n               455                  8                 54                707 \n   Rocher, éboulis     Sable, gravier      Vigne, verger   Zone d'activités \n                 1                 18                316                146 \n\n\n\n\nVisualization\n\ninteractivestatic\n\n\n\nmapview(landuse, z = \"nature\")\n\n\n\n\n\n\n\n\nplot(landuse, y = \"nature\", type = \"classes\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalculate area\nThe function expanse calculate the area in \\(m^2\\). Again, be careful with projection systems (addrefslide). Some are not suited to calculate areas. Prefer equalarea projections or use local projection system (if your study area is small). The package terra recommends the calculation of areas in lat/long to get more accurate results (accounting for Earth’s curvature).\n\n# calculate area of polygons\nlanduse$area_km2 &lt;- expanse(landuse) * 0.000001\n\n# see area per land use classes\ntapply(landuse$area_km2, landuse$nature, sum)\n\n              Bâti       Broussailles Carrière, décharge          Eau libre \n       474.8521879        891.4256281         16.2444372       2799.1424086 \n             Forêt      Marais salant  Marais, tourbière            Prairie \n      1804.7059831         33.8696654        236.7411376       1607.4753153 \n   Rocher, éboulis     Sable, gravier      Vigne, verger   Zone d'activités \n         0.3778454         18.7532616       1752.9425395        137.2554131",
    "crumbs": [
      "Day 1",
      "Vectors"
    ]
  },
  {
    "objectID": "chapters/13_rasters.html",
    "href": "chapters/13_rasters.html",
    "title": "Rasters",
    "section": "",
    "text": "Introduction\nAt the end of this tutorial, you will be know :\nRaster spatial data are also called gridded dataset, or matrices.\nThe most commun file types are: addrefslide\n- GeoTIFF (.tif) - netCDF (.nc), … (addref) - ASCII Grid (.asc)\nFor working with rasters, the recommended R-package is terra (but you can also check out stars(addref)).\nDuring this tutorial, we will focus on simple one dimensional raster. Next day, we will see how to handle multidimensional rasters (addref).\nLet’s start with loading the required packages.\nlibrary(terra) |&gt; suppressPackageStartupMessages()\nlibrary(mapview)\nlibrary(here) |&gt; suppressPackageStartupMessages()",
    "crumbs": [
      "Day 1",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/13_rasters.html#introduction",
    "href": "chapters/13_rasters.html#introduction",
    "title": "Rasters",
    "section": "",
    "text": "Load raster from a geotiff file\n\nlocalonline\n\n\n\nbdalti &lt;- rast(here(\"data\", \"BDALTI_mpl50km.tif\"))\n\n\n\n\nbdalti &lt;- rast(\n  \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDALTI_mpl50km.tif\"\n)\n\n\n\n\n\n\nHandling rasters\n\nbdalti\n\nclass       : SpatRaster \nsize        : 432, 439, 1  (nrow, ncol, nlyr)\nresolution  : 250, 250  (x, y)\nextent      : 715438.3, 825188.3, 6233959, 6341959  (xmin, xmax, ymin, ymax)\ncoord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154) \nsource      : BDALTI_mpl50km.tif \nname        : BDALTI_mpl50km \n\n# get the dimension: dim()\ndim(bdalti) # number of x, y and z dimensions\n\n[1] 432 439   1\n\n# check the projection system : crs()\ncrs(bdalti, describe = TRUE)\n\n                   name authority code\n1 RGF93 v1 / Lambert-93      EPSG 2154\n                                                                                           area\n1 France - onshore and offshore, mainland and Corsica (France métropolitaine including Corsica)\n                      extent\n1 -9.86, 10.38, 41.15, 51.56\n\n# get the extent : ext()\next(bdalti)\n\nSpatExtent : 715438.281255682, 825188.281255682, 6233958.55620402, 6341958.55620402 (xmin, xmax, ymin, ymax)\n\n# get the name of the layer\nnames(bdalti)\n\n[1] \"BDALTI_mpl50km\"\n\n# rename the layer (for simplicity)\nnames(bdalti) &lt;- \"elevation\"\n\n# get all the values : values()\n# use only for small raster, else it takes large amount of time and memory\nboxplot(values(bdalti), ylab = \"elevation (m)\")\n\n\n\n\n\n\n\n# mean elevation in our study area\nmean(values(bdalti))\n\n[1] 198.9497\n\n\n\n\nVisualization\n\ninteractivestatic\n\n\n\nmapview(bdalti)\n\n\n\n\n\n\n\n\nplot(bdalti)\n\n\n\n\n\n\n\n\n\n\n\n\nSet NA values\nLet’s imagine we want to remove the sea and all values below 0\n\n# make sure values are between 0 and 2000 m\nalti &lt;- clamp(bdalti, 0, 2000, values = TRUE)\n# set values with elevation 0 as NA (remove the sea)\nNAflag(alti) &lt;- 0\nplot(alti)\n\n\n\n\n\n\n\n# mean elevation in our study area (excluding sea)\nmean(values(alti), na.rm = TRUE)\n\n[1] 252.6259\n\n\n\n\n\nRaster algebra\nAll kind of mathematical operations are possible. For instance square root transformation.\n\nsqrt_alti &lt;- sqrt(alti)\n\nplot(sqrt_alti)\n\n\n\n\n\n\n\n\n\n\nClassify values\nIf large file, might be good to save the output.\n\n# set the breaks of the class\nbks &lt;- c(-1, 1, 5, 10, 50, 100, 500, 1000, 5000)\n# classify values\nalti_class &lt;- classify(bdalti, bks, include.lowest = TRUE, brackets = TRUE)\n# get how many pixel per class\ntable(values(alti_class))\n\n\n    0     1     2     3     4     5     6     7 \n45055 15260  3318 15902 21617 60047 24797  3652 \n\n# the raster is a factor\nis.factor(alti_class)\n\n[1] TRUE\n\n# see the labels of the class\nlevels(alti_class)\n\n[[1]]\n  ID     elevation\n1  0      [-1 - 1]\n2  1       (1 - 5]\n3  2      (5 - 10]\n4  3     (10 - 50]\n5  4    (50 - 100]\n6  5   (100 - 500]\n7  6  (500 - 1000]\n8  7 (1000 - 5000]\n\n# visualize the elevation class\nplot(alti_class)\n\n\n\n\n\n\n\n\n\n\nExport raster in Geotiff\n\nwriteRaster(alti_class, filename = here(\"data\", \"BDALTI_class.tif\"))\n\nWhen exporting as geotiff, it keeps an additional file with extension .tif.aux.xml that store the information of labels of the levels.\n\n\nCalculate slope\nFor elevation raster, there is a function that can compute multiple terrain characteristics (such as slope, roughness indicators or flow direction): terra::terrain().\n\nslope &lt;- terrain(alti, v = \"slope\")\nplot(slope)\n\n\n\n\n\n\n\n\n\n\nVectorization\nRasters can be vectorize as contour (isoline), the output will be lines.\n\nalti_iso = as.contour(bdalti, levels = bks)\nplot(alti_iso, \"level\")\n\n\n\n\n\n\n\n\nRasters containing classes can be vectorize as polygons.\n\nalti_vect = as.polygons(as.numeric(alti_class))\nplot(alti_vect, \"elevation\")\n\n\n\n\n\n\n\n\n\n\nDownsample\nIn same case, it might be interesting to degrade the spatial resolution and aggregate values of neighbouring pixel. This can be done with terra::aggregate()\n\nlow_alti &lt;- aggregate(bdalti, 10)\nplot(low_alti)\n\n\n\n\n\n\n\n\nWhat is the resolution of the newly aggregated raster? In which unit?\n\n\nProjection\nIn the case of extracting values from raster to vector, it is recommended to project the vectors to match the projection of the rasters. But in some case, it might be useful to project a raster, for instance if you have multiple rasters and want to have a common projection system.\n\nalti_4326 &lt;- project(bdalti, \"EPSG:4326\")\nalti_4326\n\nclass       : SpatRaster \nsize        : 363, 508, 1  (nrow, ncol, nlyr)\nresolution  : 0.002705848, 0.002705848  (x, y)\nextent      : 3.189833, 4.564404, 43.19424, 44.17647  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nname        :    elevation \nmin value   :   -0.7601026 \nmax value   : 1524.4808350 \n\n# remove negative values\nalti_4326 &lt;- clamp(alti_4326, 0, 2000)\n# plot the projected raster\nplot(alti_4326)\n\n\n\n\n\n\n\n\nIt appear tiled because of the projection. What is the resolution of the newly projected raster? In which unit?",
    "crumbs": [
      "Day 1",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/13_rasters.html#from-polygons-to-raster",
    "href": "chapters/13_rasters.html#from-polygons-to-raster",
    "title": "Rasters",
    "section": "From polygons to raster",
    "text": "From polygons to raster\n\nLoad the land use dataset\n\nlocalonline\n\n\n\nlanduse &lt;- vect(here(\"data\", \"BDCARTO-LULC_mpl50km.shp\"))\n\n\n\n\nlanduse &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-LULC_mpl50km.shp\"\n)\n\n\n\n\n\n\nHandling spatial vectors\n\n# get the number of objects, and the number of attributes\ndim(landuse)\n\n[1] 2384    3\n\n# get the projection system\ncrs(landuse, describe = TRUE)\n\n    name authority code area         extent\n1 WGS 84      EPSG 4326 &lt;NA&gt; NA, NA, NA, NA\n\n# see a subset of the data\nhead(landuse, 3)\n\n                    id                   cleabs       nature\n1 occupation_du_sol.32 BDC_OCS_0000002201861697 Broussailles\n2 occupation_du_sol.68 BDC_OCS_0000002201863362         Bâti\n3 occupation_du_sol.98 BDC_OCS_0000002201860189    Eau libre\n\n# see the distribution of land cover classes (number of polygons)\ntable(landuse$nature)\n\n\n              Bâti       Broussailles Carrière, décharge          Eau libre \n               360                235                 35                 49 \n             Forêt      Marais salant  Marais, tourbière            Prairie \n               455                  8                 54                707 \n   Rocher, éboulis     Sable, gravier      Vigne, verger   Zone d'activités \n                 1                 18                316                146 \n\n\n\n\nRasterization\nTo rasterize polygons, we need to set the grid of the raster. How to set the grid depends on the objective of the subsequent analysis. In our case, there can be multiple solutions:\n\nRasterization with native grid and set resolution (if no other rasters are present in the analysis)\nRasterization with grid from BD_ALTI in Lambert 93 (if all analysis will be carried out in Lambert-93)\nRasterization with grid from BD_ALTI in lat/long (why would you do that?)\n\n\nnativeEPSG:4326EPSG:2154\n\n\nRasterization with native grid and set resolution\n\n# create a grid with resolution 0.001 degree\ngrd_lulc &lt;- rast(landuse, res = 0.001)\ngrd_lulc # no value, only grid\n\nclass       : SpatRaster \nsize        : 909, 1247, 1  (nrow, ncol, nlyr)\nresolution  : 0.001, 0.001  (x, y)\nextent      : 3.248306, 4.495306, 43.15835, 44.06735  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \n\nhasValues(grd_lulc)\n\n[1] FALSE\n\nlulc_rast_0001 &lt;- rasterize(landuse, grd_lulc, \"nature\")\nlulc_rast_0001\n\nclass       : SpatRaster \nsize        : 909, 1247, 1  (nrow, ncol, nlyr)\nresolution  : 0.001, 0.001  (x, y)\nextent      : 3.248306, 4.495306, 43.15835, 44.06735  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\ncategories  : nature \nname        :           nature \nmin value   :     Broussailles \nmax value   : Zone d'activités \n\nhasValues(lulc_rast_0001)\n\n[1] TRUE\n\nplot(lulc_rast_0001)\n\n\n\n\n\n\n\n\n\n\nRasterization with the grid of BD alti in 4326\n\nlulc_rast_4326 &lt;- rasterize(landuse, alti_4326, \"nature\")\nlulc_rast_4326\n\nclass       : SpatRaster \nsize        : 363, 508, 1  (nrow, ncol, nlyr)\nresolution  : 0.002705848, 0.002705848  (x, y)\nextent      : 3.189833, 4.564404, 43.19424, 44.17647  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\ncategories  : nature \nname        :           nature \nmin value   :     Broussailles \nmax value   : Zone d'activités \n\nplot(lulc_rast_4326)\n\n\n\n\n\n\n\n\n\n\nRasterization with the grid in Lambert 93\n\n# need to project the polygon first\nlanduse_2154 &lt;- project(landuse, crs(bdalti))\nlulc_rast_2154 &lt;- rasterize(landuse_2154, bdalti, \"nature\")\nlulc_rast_2154\n\nclass       : SpatRaster \nsize        : 432, 439, 1  (nrow, ncol, nlyr)\nresolution  : 250, 250  (x, y)\nextent      : 715438.3, 825188.3, 6233959, 6341959  (xmin, xmax, ymin, ymax)\ncoord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154) \nsource(s)   : memory\nvarname     : BDALTI_mpl50km \ncategories  : nature \nname        :           nature \nmin value   :     Broussailles \nmax value   : Zone d'activités \n\nplot(lulc_rast_2154)",
    "crumbs": [
      "Day 1",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/13_rasters.html#extra-multi-layers-raster",
    "href": "chapters/13_rasters.html#extra-multi-layers-raster",
    "title": "Rasters",
    "section": "Extra : Multi layers raster",
    "text": "Extra : Multi layers raster\nIn some case, it is convenient to have all raster in a single file, and following the same grid. For instance, then we can make mathematical operations between different layers. (addref day2)\n\nCombining multiple rasters\nWhen two rasters follow the same grid, they can be combine with c()\n\n# merge the two information (same grid)\nmpl &lt;- c(bdalti, lulc_rast_2154)\nnames(mpl)[2] &lt;- \"landuse\"\ndim(mpl)\n\n[1] 432 439   2\n\nplot(mpl)\n\n\n\n\n\n\n\n\nIt can also be saved as geotiff.\n\nwriteRaster(mpl, filename = here(\"data\", \"MPL_elevation_lulc.tif\"))\n\n\n\nResampling\nIn most cases, the grid among multiple raster do not match. In that case you need to decide which resolution to keep.\nAs an example, BDalti (lambert-93, 250m resolution), and Landuse (lat/long, 0.001 resolution). We want all data in lat/long, 0.001 resolution\n\nalti_0001 &lt;- resample(alti_4326, lulc_rast_0001, \"bilinear\")\nplot(alti_0001, \"elevation\")\n\n\n\n\n\n\n\nmpl_4326 &lt;- c(alti_0001, lulc_rast_0001)\ndim(mpl_4326)\n\n[1]  909 1247    2\n\nplot(mpl_4326)\n\n\n\n\n\n\n\n\n\n\nOther extra:\ncalculate distance (extra_distpoint)",
    "crumbs": [
      "Day 1",
      "Rasters"
    ]
  },
  {
    "objectID": "chapters/14_extract.html",
    "href": "chapters/14_extract.html",
    "title": "Extract",
    "section": "",
    "text": "Load the datasets\nAt the end of this tutorial, you will be know how to:\nNow that we know the basic formats (vectors addref and raster addref), let’s dive to the most interesting facet: extracting information from different data types.\nThere is a single key function: terra::extract().\nlibrary(terra) |&gt; suppressPackageStartupMessages()\nlibrary(mapview)\nlibrary(here) |&gt; suppressPackageStartupMessages()\nThe basic data is the GBIF otter dataset. We want to characterize the environment where these occurrences happened.\n# transform into a spatial object\npt_otter &lt;- vect(\n  otter,\n  geom = c(\"decimalLongitude\", \"decimalLatitude\"),\n  crs = \"EPSG:4326\"\n)",
    "crumbs": [
      "Day 1",
      "Extract"
    ]
  },
  {
    "objectID": "chapters/14_extract.html#load-the-datasets",
    "href": "chapters/14_extract.html#load-the-datasets",
    "title": "Extract",
    "section": "",
    "text": "localonline\n\n\n\notter &lt;- read.csv(here(\"data\", \"gbif_otter_2021_mpl50km.csv\"))\n\n\n\n\notter &lt;- read.csv(\n  \"https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.csv\"\n)",
    "crumbs": [
      "Day 1",
      "Extract"
    ]
  },
  {
    "objectID": "chapters/14_extract.html#points-to-polygon",
    "href": "chapters/14_extract.html#points-to-polygon",
    "title": "Extract",
    "section": "Points to polygon",
    "text": "Points to polygon\nLet’s load the administrative borders of the area and extract the commune where the otter were spotted.\n\nlocalonline\n\n\n\npoly_commune &lt;- vect(here(\"data\", \"BDCARTO-Commune_mpl50km.gpkg\"))\n\n\n\n\npoly_commune &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/main/data/BDCARTO-Commune_mpl50km.gpkg\"\n)\n\n\n\n\nBefore making extraction, it is recommended to plot the data (if not too big), to make sure the projection systems are the same and the extents match. Do not use mapview (interactive map) because it will automatically project the data.\n\nplot(poly_commune)\nplot(pt_otter, add = TRUE, col = \"red\")\n\n\n\n\n\n\n\n# make sure it is the same projection\ncrs(poly_commune) == crs(pt_otter)\n\n[1] TRUE\n\n\nExtract the commune\n\npt_commune &lt;- extract(poly_commune, pt_otter)\n\nWhich commune with most observation?\n\nsort(table(pt_commune$nom_officiel), decreasing = TRUE)[1:5]\n\n\nSaint-Maurice-Navacelles                    Rouet               Lansargues \n                       9                        5                        3 \n          Mas-de-Londres                  Vailhan \n                       3                        3 \n\n\nExtra: How many observation per commune?\n\nbarplot(\n  table(table(pt_commune$nom_officiel)),\n  xlab = \"number of otter observations\",\n  ylab = \"number of municipalities\"\n)\n\n\n\n\n\n\n\n# if we want to consider all commune in the poly_commune\n# create a new factor with all commune considered\nobs_commune &lt;- factor(\n  pt_commune$nom_officiel,\n  levels = sort(unique(poly_commune$nom_officiel))\n)\n\nbarplot(\n  table(table(obs_commune)),\n  xlab = \"number of otter observations\",\n  ylab = \"number of municipalities (log)\"\n)\n\n\n\n\n\n\n\n\nExercice: Do the same for land use land cover data",
    "crumbs": [
      "Day 1",
      "Extract"
    ]
  },
  {
    "objectID": "chapters/14_extract.html#points-to-raster",
    "href": "chapters/14_extract.html#points-to-raster",
    "title": "Extract",
    "section": "Points to raster",
    "text": "Points to raster\nExample with numerical values\n\nlocalonline\n\n\n\nbdalti &lt;- rast(here(\"data\", \"BDALTI_mpl50km.tif\"))\n\n\n\n\nbdalti &lt;- rast(\n  \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDALTI_mpl50km.tif\"\n)\n\n\n\n\n\nnames(bdalti) &lt;- \"elevation\"\nbdalti\n\nclass       : SpatRaster \nsize        : 432, 439, 1  (nrow, ncol, nlyr)\nresolution  : 250, 250  (x, y)\nextent      : 715438.3, 825188.3, 6233959, 6341959  (xmin, xmax, ymin, ymax)\ncoord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154) \nsource      : BDALTI_mpl50km.tif \nname        : elevation \n\ncrs(bdalti) == crs(pt_otter)\n\n[1] FALSE\n\n\nIn this case, the projection are not the same. It is recommended to project the points instead of the raster (much faster).\n\npt_2154 &lt;- project(pt_otter, crs(bdalti))\n\n\nplot(bdalti, \"elevation\")\nplot(pt_2154, add = TRUE, col = \"red\")\n\n\n\n\n\n\n\n\n\npt_alti &lt;- extract(bdalti, pt_2154)\n\n\nboxplot(pt_alti$elevation, ylab = \"elevation (m)\")\n\n\n\n\n\n\n\n\nExtra: compare with data from GBIF\n\n# check with recorded\nplot(\n  pt_alti$elevation,\n  pt_otter$elevation,\n  xlab = \"elevation (m) GBIF values\",\n  ylab = \"elevation (m) BDALTI values\",\n  asp = 1\n)\n# add identity line\nabline(a = 0, b = 1)",
    "crumbs": [
      "Day 1",
      "Extract"
    ]
  },
  {
    "objectID": "chapters/14_extract.html#polygons-to-raster",
    "href": "chapters/14_extract.html#polygons-to-raster",
    "title": "Extract",
    "section": "Polygons to raster",
    "text": "Polygons to raster\nexample with buffer from points zonal could be faster? and mention exactextractr package which is much faster for large dataset.\n\nCreate buffer\n\npoly_otter &lt;- buffer(pt_2154, 1000)\npoly_otter\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 83, 13  (geometries, attributes)\n extent      : 722524.6, 819474.4, 6244001, 6331039  (xmin, xmax, ymin, ymax)\n coord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154) \n names       :       key institutionCode     species occurrenceStatus\n type        :     &lt;num&gt;           &lt;chr&gt;       &lt;chr&gt;            &lt;chr&gt;\n values      : 3.059e+09     iNaturalist Lutra lutra          PRESENT\n               3.854e+09    UAR PatriNat Lutra lutra          PRESENT\n               3.854e+09    UAR PatriNat Lutra lutra          PRESENT\n       eventDate  year month   day elevation identificationVerificationStatus\n           &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;                            &lt;chr&gt;\n 2021-01-24T15:~  2021     1    24        NA                               NA\n      2021-01-13  2021     1    13        NA                         Probable\n      2021-01-08  2021     1     8        NA                         Probable\n (and 3 more)\n             \n             \n             \n             \n\n\n\n\nGet average elevation\n\nmean_alti &lt;- extract(bdalti, poly_otter, fun = mean)\n\nplot(mean_alti$elevation, pt_alti$elevation)\n\n\n\n\n\n\n\n\n\n\nGet variation of elevation\n\nsd_alti &lt;- extract(bdalti, poly_otter, fun = sd)\n\nplot(sd_alti$elevation, pt_alti$elevation)\n\n\n\n\n\n\n\n\nExtra: is variation linked to average slope?\n\n\nGet all values\n\nfull_alti &lt;- extract(bdalti, poly_otter)\n\n# number of pixel per buffer (around 50)\ntable(table(full_alti$ID))\n\n\n47 48 49 50 51 52 \n 1  3  6 49 12 12 \n\nmed_otter &lt;- tapply(full_alti$elevation, full_alti$ID, median)\n\n\n\nWith categorical raster\nslightly more complicated (but there might exist a faster function)\n\nbks &lt;- c(0, 1, 5, 10, 50, 100, 500, 1000, 5000)\nalti_class &lt;- classify(bdalti, bks, include.lowest = TRUE, brackets = TRUE)\n\npoly_class &lt;- extract(alti_class, poly_otter, exact = TRUE)\n\nsummary_class &lt;- tapply(\n  poly_class$fraction,\n  list(poly_class$ID, poly_class$elevation),\n  sum\n)\nsum_class &lt;- rowSums(summary_class, na.rm = TRUE)\nboxplot(sum_class)\n\n\n\n\n\n\n\nperc_class &lt;- summary_class / sum_class * 100\nperc_class[is.na(perc_class)] &lt;- 0\nhead(perc_class)\n\n  [0 - 1]  (1 - 5] (5 - 10] (10 - 50] (50 - 100] (100 - 500] (500 - 1000]\n1       0  0.00000  0.00000  0.000000   0.000000         100            0\n2       0  0.00000 61.36846 38.631539   0.000000           0            0\n3       0 16.28031 75.27533  8.444359   0.000000           0            0\n4       0  0.00000  0.00000 94.383791   5.616209           0            0\n5       0  0.00000 61.36846 38.631539   0.000000           0            0\n6       0  0.00000  0.00000  0.000000   0.000000         100            0\n  (1000 - 5000]\n1             0\n2             0\n3             0\n4             0\n5             0\n6             0",
    "crumbs": [
      "Day 1",
      "Extract"
    ]
  },
  {
    "objectID": "chapters/14_extract.html#polygons-to-polygons",
    "href": "chapters/14_extract.html#polygons-to-polygons",
    "title": "Extract",
    "section": "Polygons to polygons",
    "text": "Polygons to polygons\nthe land use per point or per buffer\n\nlocalonline\n\n\n\nlanduse &lt;- vect(here(\"data\", \"BDCARTO-LULC_mpl50km.shp\"))\n\n\n\n\nlanduse &lt;- vect(\n  \"https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-LULC_mpl50km.shp\"\n)\n\n\n\n\nIn this case, faster to project the buffer point than the polygons\n\n# project the buffer\npoly_4326 &lt;- project(poly_otter, crs(landuse))\n\n#make sure land use and buffer are in the same projection\nplot(landuse, \"nature\")\nplot(poly_4326, add = TRUE, col = \"red\")\n\n\n\n\n\n\n\nfull_lulc &lt;- intersect(landuse, poly_4326)\n# visualize the intersection\nmapview(full_lulc, z = \"nature\")\n\n\n\n\n\n\nfull_lulc$area_km2 &lt;- expanse(full_lulc) * 0.000001\n\nocc &lt;- tapply(full_lulc$area_km2, list(full_lulc$key, full_lulc$nature), sum)\n#replace NA by 0\nocc[is.na(occ)] &lt;- 0\n\nsum_occ &lt;- rowSums(occ)\nsummary(sum_occ)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.966   3.127   3.128   3.113   3.128   3.129 \n\npoly_4326$overlay_area &lt;- sum_occ\n\nperc_occ &lt;- occ / sum_occ * 100\nhead(perc_occ)\n\n                Bâti Broussailles Carrière, décharge Eau libre    Forêt\n3039400167  0.000000    55.587617                  0         0 31.96645\n3039481391  0.000000     0.000000                  0         0 64.24183\n3058935748  0.000000    14.376508                  0         0 49.90804\n3124766650  0.000000    13.167920                  0         0 50.22884\n3456660648  1.769663     3.825537                  0         0 77.09612\n3853886594 48.946916     0.000000                  0         0  0.00000\n           Marais, tourbière  Prairie Sable, gravier Vigne, verger\n3039400167                 0 12.44593              0      0.000000\n3039481391                 0 35.75817              0      0.000000\n3058935748                 0 33.10966              0      2.605794\n3124766650                 0 33.58404              0      3.019194\n3456660648                 0 17.30868              0      0.000000\n3853886594                 0  0.00000              0     51.053084\n           Zone d'activités\n3039400167                0\n3039481391                0\n3058935748                0\n3124766650                0\n3456660648                0\n3853886594                0\n\n# add information in the spatial vector\npt_res &lt;- cbind(pt_otter, perc_occ)\nmapview(pt_res, z = \"Forêt\", layer.name = \"% foret\")\n\n\n\n\npt_lulc &lt;- extract(landuse, pt_otter)\npt_res$LULC &lt;- pt_lulc$nature\n\nboxplot(pt_res$Forêt ~ pt_res$LULC, horizontal = TRUE, las = 1, ylab = \"\")",
    "crumbs": [
      "Day 1",
      "Extract"
    ]
  },
  {
    "objectID": "chapters/21_multilayer.html",
    "href": "chapters/21_multilayer.html",
    "title": "Multi-layer rasters",
    "section": "",
    "text": "At the end of this tutorial, you will be know how to:\n\nhandle multilayer rasters\n\nextract time series or vegetation indices from rasters",
    "crumbs": [
      "Day 2",
      "Multi-layer rasters"
    ]
  },
  {
    "objectID": "chapters/22_interactivemap.html",
    "href": "chapters/22_interactivemap.html",
    "title": "Interactive maps",
    "section": "",
    "text": "At the end of this tutorial, you will be know how to:\n\ncreate an interactive map\n\nfew tricks to improve the layout or safeguard the anonymity of your data",
    "crumbs": [
      "Day 2",
      "Interactive maps"
    ]
  },
  {
    "objectID": "chapters/31_toydata_mpl.html",
    "href": "chapters/31_toydata_mpl.html",
    "title": "Create a toy dataset from GBIF and IGN data",
    "section": "",
    "text": "1. Set the spatial extent\nThis is a small practical example on how get data from GBIF and IGN based on a geographical area. For this tutorial, we will need sf, mapview, happign, and rgbif packages.\nFor this example, we will focus on an area around FRB-CESAB in Montpellier. So we will need to\n(1) find the coordinates of FRB-CESAB (2) create a buffer area",
    "crumbs": [
      "Extra",
      "Create a toy dataset from GBIF and IGN data"
    ]
  },
  {
    "objectID": "chapters/31_toydata_mpl.html#set-the-spatial-extent",
    "href": "chapters/31_toydata_mpl.html#set-the-spatial-extent",
    "title": "Create a toy dataset from GBIF and IGN data",
    "section": "",
    "text": "Get coordinates from an address\nThis task is called geocoding. Among other resource, we recommend the package rgeoservices (if in France, based on french IGN services) or the package tidygeocoder using Open Street Map data.\n\nrgeoservicestidygeocodermanual\n\n\n\ncesab &lt;- rgeoservices::gs_get_coordinates(\n  query = \"5 rue de l’École de médecine, 34000 MONTPELLIER\",\n  index = \"address\"\n)\n\n\n\n\ncesab &lt;- tidygeocoder::geocode(\n  data.frame(x = \"5 rue de l’École de médecine, 34000 MONTPELLIER\"),\n  address = \"x\",\n  method = \"osm\"\n)\n# for compatibility with other solutions, rename the columns\nnames(cesab) &lt;- c(\"x\", \"latitude\", \"longitude\")\n\n\n\n\n# for such a simple case, it's easier to get coordinates from GoogleMap\n# https://maps.app.goo.gl/woqBZSs63zSjHUsS9\ncesab &lt;- data.frame(\n  \"latitude\" = 43.61269208391402,\n  \"longitude\" = 3.8733758693843585\n)\n\n\n\n\n\n\nCreate a spatial object from coordinates\nWe will use the function sf::st_as_sf() with the names of the columns for the longitude (x), the latitude (y) and the Coordinate Reference System (CRS) which is EPSG:4326.\n\n# create st_point\npt_cesab &lt;- st_as_sf(\n  cesab,\n  coords = c(\"longitude\", \"latitude\"),\n  crs = 4326\n)\n\n\n\nCreate a buffer from points\nWe want a buffer zone of 50km around the FRB-Cesab. Because GBIF only accept rectangle buffer, we will take the square that include the circular buffer.\n\nbuffer_size &lt;- 50000 # in m because data are in EPSG 4326\n\n# create a round buffer zone\nb_circle &lt;- st_buffer(pt_cesab, buffer_size)\n\n# transform to square because occ_search() needs rectangle\nb_square &lt;- st_bbox(b_circle) |&gt; st_as_sfc()\n\nWe can visualize the spatial data created with mapview:\n\nmapview(b_square, alpha.regions = 0, lwd = 3) +\n  mapview(b_circle, alpha.regions = 0.1, lwd = 0) +\n  mapview(pt_cesab)",
    "crumbs": [
      "Extra",
      "Create a toy dataset from GBIF and IGN data"
    ]
  }
]