# Vectors {.unnumbered}

At the end of this tutorial, you will be know :    

- what is a spatial vector data type   
- how to create and modify one  
- how to read and write  the most common formats


## Introduction

Typically, there are three types of vectors: *addrefslide*  

- Points
- Lines
- Polygons


The most common formats are: *addrefslide*  

- ESRI shapefile (.shp) : the traditional and most frequently used format
- Geopackages (.gpkg) : the new standard
- GPS Exchange Format (.gpx)
- Google Earth file (.kml / .kmz)


There are two main packages in R to work with spatial vectors: `terra` and `sf` (that replace older packages such as `raster` and `sp`). This tutorial will mostly use the package `terra` for smoother integration with the rest of the tutorial (especially working with rasters), but most functions have their equivalent in `sf`.  

At the start of the tutorial, equivalent functions in `sf` will be shown.

Let's start with loading the required packages.

```{r setting}
library(terra) |> suppressPackageStartupMessages()
library(mapview)
library(here) |> suppressPackageStartupMessages()
library(sf) |> suppressPackageStartupMessages()
```


## Points 

### Creating spatial points from data

This is the most common case: you have coordinates from a (csv/excel/text) file and you want to get spatial information about these locations. The first step is to transform the coordinates as proper spatial object in R.

We will use a dataset from GBIF(*addref*) with all occurrences of otter recorded in 2021 within a 50km buffer from Montpellier, France. This data was prepared and stored on Github. 

::: {.panel-tabset}

## local
```{r}
otter <- read.csv(here("data", "gbif_otter_2021_mpl50km.csv"))
```

## online
```{r otter}
#| eval: false
otter <- read.csv(
  "https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.csv"
)
```

:::


```{r explore_otter}
dim(otter)
names(otter)
table(otter$institutionCode)
```

The dataset contains 83 observations of otter (in rows), and 15 variables (in column) such as date, coordinates, and data provider. The geographic coordinates are stored in the columns `decimalLongitude`, and `decimalLatitude`. They are expressed in decimal degrees, with the standard datum WGS84 [EPSG:4326](https://epsg.io/4326).  

Let's **create a spatial object from the coordinates**.

::: {.panel-tabset}

## terra
In `terra`, the key function is `terra::vect()`.

```{r terra_otter}
pt_terra <- vect(
  otter,
  geom = c("decimalLongitude", "decimalLatitude"),
  crs = "EPSG:4326"
)
# summary
pt_terra
# visualization
plot(pt_terra)
```

## sf
In `sf`, the key function is `sf::st_as_sf()`.

```{r sf_otter}
pt_sf <- st_as_sf(
  otter,
  coords = c("decimalLongitude", "decimalLatitude"),
  crs = "EPSG:4326"
)
# summary
pt_sf
# visualization
plot(pt_sf, max.plot = 1, axes = TRUE)
```

:::

### Handling spatial vectors

Let's have a look at the most common functions to handle spatial vectors in R.

::: {.panel-tabset}

## terra

```{r terra_pt}
# get the geographical extent
ext(pt_terra)
# get number of objects, number of attributes
dim(pt_terra)
# get the projection system
crs(pt_terra, describe = TRUE)
# get the coordinates
crds(pt_terra) |> head()

# manipulate the dataset
# the attached data is formatted as a standard data.frame
# you can add a new column with '$' (for instance month labels)
pt_terra$lab_month <- month.name[pt_terra$month]

# filter rows with '[]' (for instance, keep only iNaturalist observations)
iNat_terra <- pt_terra[pt_terra$institutionCode == "iNaturalist", ]
dim(iNat_terra)
```

## sf

```{r sf_pt}
# get the geographical extent
st_bbox(pt_sf)
# get number of objects, number of attributes
dim(pt_sf)
# get the projection system
crs(pt_sf, describe = TRUE)
# get the coordinates
st_coordinates(pt_sf) |> head()

# manipulate the dataset
# the attached data is formatted as a standard data.frame
# you can add a new column with '$' (for instance month labels)
pt_sf$lab_month <- month.name[pt_sf$month]

# filter rows with '[]' (for instance, keep only iNaturalist observations)
iNat_sf <- pt_sf[pt_sf$institutionCode == "iNaturalist", ]
dim(iNat_sf)
```

:::

### Projection

There are different coordinate reference systems in which coordinates can be expressed (e.g. different unit). While manipulating multiple datasets from different sources, it is important to make sure they are all in the same coordinate system. If it is not the case, then you will need make projection to convert the projection system. *addrefslide*   

For example, in France, the preferred projection system by IGN is Lambert 93 ([EPSG:2154](https://epsg.io/2154)).As an exercise, let's project our points to EPSG:2154.


::: {.panel-tabset}

## terra
In `terra`, the key function is `terra::project()`.
```{r terra_proj}
# projection
pt_2154_terra <- project(pt_terra, "EPSG:2154")
# see the differences in the bounding box
# extent in lat/long
ext(pt_terra)
# new extent in Lambert-93
ext(pt_2154_terra)
```

## sf
In `sf`, the key function is `sf::st_transform()`.
```{r sf_proj}
#projection
pt_2154_sf <- st_transform(pt_sf, crs = "EPSG:2154")
# see the differences in the bounding box
# extent in lat/long
st_bbox(pt_sf)
# new extent in Lambert-93
st_bbox(pt_2154_sf)
```

:::

### Export the data

For vectors, it is recommended to export them as geopackage file (extension `.gpkg`). Compare to traditional ESRI shapefile, the geopackage format store the data in a single file and the column names are preserved. (*addref slide file format*).

::: {.panel-tabset}

## terra
In `terra`, the function is `terra::writeVector()`.

```{r terra_export}
#| eval: false
writeVector(pt_terra, here("data", "gbif_otter_2021_mpl50km.gpkg"))
```

## sf
In `sf`, the function is `sf::write_sf()`.

```{r sf_export}
#| eval: false
write_sf(pt_sf, here("data", "gbif_otter_2021_mpl50km.gpkg"))
```

:::


### Conversion between sf and terra 

It is confusing to have two dominant packages `terra` and `sf` having similar functionalities. Luckily, the conversion between these two format is easy.

::: {.panel-tabset}

## from terra to sp
To convert a `terra` vector into `sf`, the function is `sf::st_as_sf()`.

```{r terra_to_sf}
#| eval: false
pt_sf <- st_as_sf(pt_terra)
```

## from sf to terra
To convert a `sf` feature into `terra`, the function is `terra::vect()`.
Be careful that non-homogeneous features (mix of points, lines and polygons) can't be converted as a terra `SpatVector` object. Only homogeneous points, line or polygons can be converted into `terra` geometry. 

```{r sf_to_terra}
#| eval: false
pt_terra <- vect(pt_sf)
```

:::



## Lines

Lines are another type of vectors, made of multiple points. It is possible to create lines but in practice, it often comes from an existing spatial dataset.
In our example case study, we will load the rivers for the area of interest from BD CARTO (*addref*).

### Load lines from a geopackage file

::: {.panel-tabset}

## local
```{r line_local}
river <- vect(here("data", "BDCARTO-River_mpl50km.gpkg"))
```

## online
```{r line_online}
#| eval: false
river <- vect(
  "https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-River_mpl50km.gpkg"
)
```

:::

### Handling spatial vectors

```{r line_summary}
# get the number of objects, and the number of attributes
dim(river)
# get the projection system
crs(river, describe = TRUE)
# see a subset of the data
head(river, 3)
```


### Calculate length of lines

The function `terra::perim()` calculate the length of lines (expressed in meter). While calculating distance and length, **be careful with projection systems**. Some are not suited to calculate distance. Prefer equidistant projections or use local projection system (if your study area is small). The package `terra` recommends the calculation of distances in lat/long to get more accurate results (considering the geodesic distance, so accounting for Earth's curvature). (*addrefslide*)


```{r line_length}
# calculate the length of rivers
river$length_km <- perim(river) / 1000

# see the distribution of river length
boxplot(river$length_km, ylab = "length (km)")

# get the name of the longest river
river$toponyme[which.max(river$length_km)]
```


### Visualization

::: {.panel-tabset}

## interactive
```{r line_visint}
mapview(river, z = "length_km") +
  mapview(pt_terra, col.regions = "red", color = NA)
```

## static
```{r line_vistat}
plot(river, y = "length_km", type = "continuous")
plot(pt_terra, col = "red", add = TRUE)
```

:::


## Polygons


### Load polygons from a shapefile

::: {.panel-tabset}

## local
```{r poly_local}
landuse <- vect(here("data", "BDCARTO-LULC_mpl50km.shp"))
```

## online
```{r poly_online}
#| eval: false
landuse <- vect(
  "https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-LULC_mpl50km.shp"
)
```

:::

### Handling spatial vectors

```{r poly_summary}
# get the number of objects, and the number of attributes
dim(landuse)
# get the projection system
crs(landuse, describe = TRUE)
# see a subset of the data
head(landuse, 3)
# see the distribution of land cover classes (number of polygons)
table(landuse$nature)
```

### Visualization

::: {.panel-tabset}

## interactive
```{r poly_visint}
mapview(landuse, z = "nature")
```

## static
```{r poly_vistat}
plot(landuse, y = "nature", type = "classes")
```

:::


### Calculate area

The function `expanse` calculate the area in $m^2$. Again, **be careful with projection systems** (*addrefslide*). Some are not suited to calculate areas. Prefer equalarea projections or use local projection system (if your study area is small). The package `terra` recommends the calculation of areas in lat/long to get more accurate results (accounting for Earth's curvature). 

```{r poly_area}
# calculate area of polygons
landuse$area_km2 <- expanse(landuse) * 0.000001

# see area per land use classes
tapply(landuse$area_km2, landuse$nature, sum)
```

