# Rasters {.unnumbered}

At the end of this tutorial, you will be know :

- what is a raster data file   
- how to read the most common formats   
- how to make operations in rasters   

## Introduction

Raster spatial data are also called gridded dataset, or matrices.

The most commun file types are: *addrefslide*   
 - GeoTIFF (.tif) 
 - netCDF (.nc), ... (*addref*)
 - ASCII Grid (.asc)


For working with rasters, the recommended R-package is `terra` (but you can also check out `stars`(*addref*)).

During this tutorial, we will focus on simple one dimensional raster. Next day, we will see how to handle multidimensional rasters (*addref*).

Let's start with loading the required packages.

```{r settings}
library(terra) |> suppressPackageStartupMessages()
library(mapview)
library(here) |> suppressPackageStartupMessages()
```


### Load raster from a geotiff file

::: {.panel-tabset}

## local
```{r rast_local}
bdalti <- rast(here("data", "BDALTI_mpl50km.tif"))
```

## online
```{r rast_online}
#| eval: false
bdalti <- rast(
  "https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDALTI_mpl50km.tif"
)
```

:::

### Handling rasters

```{r rast_summary}
bdalti

# get the dimension: dim()
dim(bdalti) # number of x, y and z dimensions

# check the projection system : crs()
crs(bdalti, describe = TRUE)

# get the extent : ext()
ext(bdalti)

# get the name of the layer
names(bdalti)
# rename the layer (for simplicity)
names(bdalti) <- "elevation"

# get all the values : values()
# use only for small raster, else it takes large amount of time and memory
boxplot(values(bdalti), ylab = "elevation (m)")
# mean elevation in our study area
mean(values(bdalti))
```

### Visualization

::: {.panel-tabset}

## interactive
```{r rast_visint}
mapview(bdalti)
```

## static
```{r rast_vistat}
plot(bdalti)
```

:::

#### Set NA values
Let's imagine we want to remove the sea and all values below 0
```{r rast_NA}
# make sure values are between 0 and 2000 m
alti <- clamp(bdalti, 0, 2000, values = TRUE)
# set values with elevation 0 as NA (remove the sea)
NAflag(alti) <- 0
plot(alti)
# mean elevation in our study area (excluding sea)
mean(values(alti), na.rm = TRUE)
```


### Raster algebra

All kind of mathematical operations are possible. For instance square root transformation.

```{r rast_algebra}
sqrt_alti <- sqrt(alti)

plot(sqrt_alti)
```


### Classify values

If large file, might be good to save the output.
```{r rast_classify}
# set the breaks of the class
bks <- c(-1, 1, 5, 10, 50, 100, 500, 1000, 5000)
# classify values
alti_class <- classify(bdalti, bks, include.lowest = TRUE, brackets = TRUE)
# get how many pixel per class
table(values(alti_class))
# the raster is a factor
is.factor(alti_class)
# see the labels of the class
levels(alti_class)

# visualize the elevation class
plot(alti_class)
```

### Export raster in Geotiff

```{r rast_export}
#| eval: false
writeRaster(alti_class, filename = here("data", "BDALTI_class.tif"))
```

When exporting as geotiff, it keeps an additional file with extension `.tif.aux.xml` that store the information of labels of the levels.




### Calculate slope

For elevation raster, there is a function that can compute multiple terrain characteristics (such as slope, roughness indicators or flow direction):  `terra::terrain()`.

```{r rast_slope}
slope <- terrain(alti, v = "slope")
plot(slope)
```


### Vectorization

Rasters can be vectorize as contour (isoline), the output will be lines.
```{r rast_line}
alti_iso = as.contour(bdalti, levels = bks)
plot(alti_iso, "level")
```

Rasters containing classes can be vectorize as polygons.
```{r rast_poly}
alti_vect = as.polygons(as.numeric(alti_class))
plot(alti_vect, "elevation")
```

### Downsample

In same case, it might be interesting to degrade the spatial resolution and aggregate values of neighbouring pixel. This can be done with `terra::aggregate()`

```{r rast_downsample}
low_alti <- aggregate(bdalti, 10)
plot(low_alti)
```

What is the resolution of the newly aggregated raster? In which unit?


### Projection

In the case of extracting values from raster to vector, it is recommended to project the vectors to match the projection of the rasters. 
But in some case, it might be useful to project a raster, for instance if you have multiple rasters and want to have a common projection system.

```{r rast_proj}
alti_4326 <- project(bdalti, "EPSG:4326")
alti_4326
# remove negative values
alti_4326 <- clamp(alti_4326, 0, 2000)
# plot the projected raster
plot(alti_4326)
```

It appear tiled because of the projection. What is the resolution of the newly projected raster? In which unit?

## From polygons to raster

### Load the land use dataset

::: {.panel-tabset}

## local
```{r poly_local}
landuse <- vect(here("data", "BDCARTO-LULC_mpl50km.shp"))
```

## online
```{r poly_online}
#| eval: false
landuse <- vect(
  "https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-LULC_mpl50km.shp"
)
```

:::

### Handling spatial vectors

```{r poly_summary}
# get the number of objects, and the number of attributes
dim(landuse)
# get the projection system
crs(landuse, describe = TRUE)
# see a subset of the data
head(landuse, 3)
# see the distribution of land cover classes (number of polygons)
table(landuse$nature)
```

### Rasterization
To rasterize polygons, we need to set the grid of the raster. How to set the grid depends on the objective of the subsequent analysis. In our case, there can be multiple solutions:    

- Rasterization with native grid and set resolution (if no other rasters are present in the analysis)
- Rasterization with grid from BD_ALTI in Lambert 93 (if all analysis will be carried out in Lambert-93)
- Rasterization with grid from BD_ALTI in lat/long (why would you do that?)


::: {.panel-tabset}

## native
Rasterization with native grid and set resolution
```{r}
# create a grid with resolution 0.001 degree
grd_lulc <- rast(landuse, res = 0.001)
grd_lulc # no value, only grid
hasValues(grd_lulc)
lulc_rast_0001 <- rasterize(landuse, grd_lulc, "nature")
lulc_rast_0001
hasValues(lulc_rast_0001)
plot(lulc_rast_0001)
```

## EPSG:4326
Rasterization with the grid of BD alti in 4326
```{r}
lulc_rast_4326 <- rasterize(landuse, alti_4326, "nature")
lulc_rast_4326
plot(lulc_rast_4326)
```

## EPSG:2154
Rasterization with the grid in Lambert 93
```{r}
# need to project the polygon first
landuse_2154 <- project(landuse, crs(bdalti))
lulc_rast_2154 <- rasterize(landuse_2154, bdalti, "nature")
lulc_rast_2154
plot(lulc_rast_2154)
```

:::

## Extra : Multi layers raster

In some case, it is convenient to have all raster in a single file, and following the same grid.
For instance, then we can make mathematical operations between different layers. (*addref day2*)

### Combining multiple rasters

When two rasters follow the same grid, they can be combine with `c()`
```{r}
# merge the two information (same grid)
mpl <- c(bdalti, lulc_rast_2154)
names(mpl)[2] <- "landuse"
dim(mpl)
plot(mpl)
```

It can also be saved as geotiff.
```{r multirast_export}
#| eval: false
writeRaster(mpl, filename = here("data", "MPL_elevation_lulc.tif"))
```


### Resampling

In most cases, the grid among multiple raster do not match. In that case you need to decide which resolution to keep. 

As an example, BDalti (lambert-93, 250m resolution), and Landuse (lat/long, 0.001 resolution). We want all data in lat/long, 0.001 resolution

```{r}
alti_0001 <- resample(alti_4326, lulc_rast_0001, "bilinear")
plot(alti_0001, "elevation")

mpl_4326 <- c(alti_0001, lulc_rast_0001)
dim(mpl_4326)
plot(mpl_4326)
```


### Other extra:

calculate distance (*extra_distpoint*)