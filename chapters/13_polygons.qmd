# Polygons {.unnumbered}

:::{.callout-important title="Summary"}
This tutorial explore how to handle **spatial polygons** in R with `terra` package:

- read a spatial object with (`terra::vect()`)  
- calculate length of lines with (`terra::perim()`)
- calculate distances between points and lines with (`terra::distance()`)
:::

:::{.callout-tip title="The ecologist mind"}
In which type of habitats were the otter observed? To answer this question, we will need to discover another type of spatial vector: **polygons**.
:::

## Setup

<details>
<summary> Follow the setup instructions if you haven't followed the tutorial on [points](https://frbcesab.github.io/spatial-r/chapters/11_points.html)</summary>

If haven't done it already, please follow the [setup instructions](https://frbcesab.github.io/spatial-r/chapters/01_setup.html). Let's start with loading the required packages.

```{r setting}
suppressPackageStartupMessages({
  library(mapview)
  library(here)
  library(sf)
  library(terra)
})
```

::: {.panel-tabset}

## local
```{r otter_local}
pt_otter <- vect(here("data", "gbif_otter_2021_mpl50km.gpkg"))
```

## online
```{r otter_online}
#| eval: false
pt_otter <- vect(
  "https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.gpkg"
)
```

:::

</details>


## Load polygons from a shapefile

In this example, we will load land cover information for the area of interest from [IGN data BD CARTO](https://geoservices.ign.fr/bdcarto).

*Note that this dataset has rough resolution (OSO or Corine land cover would be more suited for real analysis), but it's perfect for our illustration and learning purposes.* 

You can load all vector dataset in R with the function [`terra::vect()`](https://search.r-project.org/CRAN/refmans/terra/html/vect.html). 

::: {.panel-tabset}

## terra
```{r poly_local}
landuse <- vect(here("data", "BDCARTO-LULC_mpl50km.shp"))
```

## sf

```{r line_sf}
landuse_sf <- st_read(here("data", "BDCARTO-LULC_mpl50km.shp"))
```

## online
```{r poly_online}
#| eval: false
landuse <- vect(
  "https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-LULC_mpl50km.shp"
)
```

:::


:::{.callout-note title="Your turn"}
1. How many different polygons make the land cover of the area?
2. What is the coordinate reference system (CRS) of the loaded river data?
3. How many land cover classes are there? which class has most polygons?
:::

<details>
<summary>Click to see the answer</summary>

1. There was ```r nrow(landuse)``` polygons in the dataset. You can access it with `dim(landuse)`, `nrow(landuse)` or just by typing `landuse` in the console.  
2. The coordinates are in ```r crs(landuse, describe = TRUE)$name``` (EPSG ```r crs(landuse, describe = TRUE)$code```). You can access this information with `crs(landuse, describe = TRUE)` (or in `sf` with `st_crs(landuse_sf)`).
3. The column that stored the cover classes is `nature`. You could identify it with `head(landuse)` or `names(landuse)`. There are ```r length(unique(landuse$nature))``` land cover classes,  ```r names(which.max(table(landuse$nature)))``` is the class with most polygons (`table(landuse$nature)`).

</details>


## Visualization

::: {.panel-tabset}

## interactive

```{r mapview_line}
mapview(landuse, z = "nature") +
  mapview(pt_otter, col.regions = "black")
```

## terra

```{r terramap_line}
plot(landuse, y = "nature", border = NA)
plot(pt_otter, add = TRUE)
```

## sf

```{r sfmap_line}
plot(landuse_sf["nature"], reset = FALSE, border = FALSE, axes = TRUE)
plot(pt_otter, add = TRUE, pch = 16)
```

:::{.callout-warning}
If you want to overlay multiple spatial object with base plot from `sf`, don't forget to use the argument `reset=FALSE`.
:::

:::

## Calculate the area

The function `expanse` calculate the area in $m^2$. When calculating areas, **be careful with projection systems**. Some are not suited to calculate areas. Prefer equalarea projections or use local projection system (if your study area is small). 

The package `terra` recommends the calculation of areas in lat/long to get more accurate results (accounting for Earth's curvature). 
The package `sf` handle lat/long with `s2` which is not very accurate or prone to errors. 

So it is recommended to use `terra` when dealing with geographic coordinates, or projecting the coordinates in an appropriate projection system.


::: {.panel-tabset}

## terra

```{r lulc_area_terra}
# calculate the area in ha
area_polygons <- expanse(landuse) * 0.0001
# store the area as atribute
landuse$area_ha <- as.numeric(area_polygons)
```

## sf

For `sf`, it is recommended to project the dataset to a local projection, such as the Universal Transverse Mercator defined for Europe ([EPSG:25832](https://epsg.io/25832)).

```{r lulc_area_sf}
# 25832 is a commun projection for France
landuse_25832 <- st_transform(landuse_sf, crs = 25832)
# calculate area of polygons
area_polygons <- st_area(landuse_25832) * 0.0001
# store as attribute in landuse
landuse_25832$area_ha <- as.numeric(area_polygons)
```

:::


:::{.callout-note title="Your turn"}
1. Which is the largest land cover class in our study area? Why?
2. Remove the Mediterranean from the land cover dataset (hint: it is the largest polygon).
3. Calculate the percentage of terrestrial land cover in the study area.
:::

<details>
<summary>Click to see the answer</summary>

```{r ex1}
# see area per land use classes
tapply(landuse$area_ha, landuse$nature, sum)
```

</details>

<details>
<summary>Click to see the answer 2</summary>

```{r ex2}
# the largest polygon correspond to the mediterranean
landuse$nature[which.max(landuse$area_ha)]
# remove the largest polygon
landuse_nomed <- landuse[-which.max(landuse$area_ha), ]
# verify the operation
plot(landuse_nomed, y = "nature", border = NA)
```

</details>

<details>
<summary>Click to see the answer 3</summary>

```{r ex3}
cover_ha <- tapply(landuse_nomed$area_ha, landuse_nomed$nature, sum)
# percentage of land cover classes in the terrestrial study area
cover_perc <- cover_ha / sum(cover_ha) * 100
#show rounded values
round(cover_perc, 2)
```

</details>


## Points to polygons

Before making extraction, it is recommended to plot the data (if not too big), to make sure the projection systems are the same and the extents match. Do not use `mapview` (interactive map) because it will automatically project the data.


::: {.panel-tabset}
## terra

Extract the land cover class of the points with [`terra::extract()`](https://search.r-project.org/CRAN/refmans/terra/html/extract.html): 
```{r lulc_otter_terra}
pt_landcover <- extract(landuse, pt_otter)
```

## sf
Extract the land cover class of the points with [`sf::st_join()`](https://search.r-project.org/CRAN/refmans/sf/html/st_join.html): 
```{r lulc_otter_sf}
pt_landcover <- st_join(st_as_sf(pt_otter), landuse_sf)
```

:::

```{r lulc_otter_table}
# see area per land use classes of the observations
table(pt_landcover$nature)
```

:::{.callout-note title="Your turn"}
- [stat] Which classes are over or under represented compare to expected? (to complex?)
:::

<details>
<summary>Click to see the answer</summary>

```{r ex4}
# see area per land use classes of the observations
cover_obs_perc <- table(pt_landcover$nature) / nrow(pt_landcover) * 100
# add missing classes
m0 <- match(names(cover_perc), names(cover_obs_perc))
cover <- data.frame(
  class = names(cover_perc),
  all = as.numeric(cover_perc),
  obs = as.numeric(cover_obs_perc[m0])
)
cover[is.na(cover)] <- 0
cover$delta <- cover$obs - cover$all
barplot(cover$delta, horiz = TRUE, names = cover$class, las = 1)
```


</details>

## Polygons to polygons

In many cases, we want to characterize the area surrounding the observations. So we will create buffers. 

### Create buffer

::: {.panel-tabset}

## terra
We can create buffer with [`terra::buffer()`](https://search.r-project.org/CRAN/refmans/terra/html/buffer.html).

```{r buffer_terra}
dist_buffer <- 1000 # buffer of 1000 m
poly_otter <- buffer(pt_otter, dist_buffer)
```

## sf
Same here, `sf` uses `s2` with geographic coordinates (e.g. EPSG:4326) which creates buffers with low quality (as in sf 1.0-21 on 03/11/2025).  
So it is recommended to use projected coordinates with [`sf::st_buffer()`](https://search.r-project.org/CRAN/refmans/sf/html/geos_unary.html).

```{r buffer_sf}
dist_buffer <- 1000 # buffer of 1000 m
# transform as UTM : better for area
pt_otter_25832 <- st_as_sf(pt_otter) |> st_transform(25832)
poly_otter_25832 <- st_buffer(pt_otter_25832, dist_buffer)
```

:::


### Visualize buffer

::: {.panel-tabset}

## terra
```{r map_buffer_terra}
plot(poly_otter[1])
plot(pt_otter[1], add = TRUE)
```

## sf

```{r map_buffer_sf}
plot(st_geometry(poly_otter_25832)[1], reset = FALSE, axes = TRUE)
plot(st_geometry(pt_otter_25832)[1], add = TRUE)
```



:::


:::{.callout-note title="Your turn"}
- What are the areas of the newly created buffers? 
:::

<details>
<summary>Click to see the answer</summary>

```{r ex5}
# see area per land use classes of the observations
summary(expanse(poly_otter))
# for sf
summary(st_area(poly_otter_25832))
```

The difference with ```r pi*1000000``` is due to the way the circle is defined (in only 40 points in `terra` and 120 points in `sf`). But what is more important is that all buffers have the same area. 
</details>




### Intersection

::: {.panel-tabset}

## terra
```{r buffer_lulc_terra}
buffer_landcover <- intersect(landuse, poly_otter)

# visualize the intersection (not plotted to lighten the webpage)
# mapview(buffer_landcover, z = "nature")

# show a zoom on the land cover of the first buffer
plot(
  buffer_landcover[buffer_landcover$key %in% poly_otter$key[1]],
  y = "nature"
)
```

## sf
```{r buffer_lulc_sf}
buffer_landcover_sf <- st_intersection(poly_otter_25832, landuse_25832)

# visualize the intersection (not plotted to lighten the webpage)
# mapview(buffer_landcover, z = "nature")
```

:::

### Land cover per buffer 

We need to recalculate the area of the intersected land cover.

```{r perc_lulc_terra}
buffer_landcover$area_ha <- expanse(buffer_landcover) * 0.0001

# Calculate area per buffer and nature class
class_area <- tapply(
  buffer_landcover$area_ha,
  list(buffer_landcover$key, buffer_landcover$nature),
  sum
)
#replace NA by 0
class_area[is.na(class_area)] <- 0
# calculate the overlay area
sum_area <- rowSums(class_area)
# calculate the percentage per class
perc_class <- class_area / sum_area * 100

barplot(apply(perc_class, 2, mean), las = 2)
```


