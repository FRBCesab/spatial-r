# Polygons {.unnumbered}

:::{.callout-important title="Summary"}
This tutorial explore how to handle **spatial polygons** in R with `terra` package:

- read a spatial object with [`terra::vect()`](https://search.r-project.org/CRAN/refmans/terra/html/vect.html)    
- calculate the area of polygons with [`terra::expanse()`](https://search.r-project.org/CRAN/refmans/terra/html/expanse.html)    
- extract values of polygons to points with [`terra::extract()`](https://search.r-project.org/CRAN/refmans/terra/html/extract.html)    
- create buffers around points with [`terra::buffer()`](https://search.r-project.org/CRAN/refmans/terra/html/buffer.html)   
- find intersection among two polygon layers with  [`terra::intersect()`](https://search.r-project.org/CRAN/refmans/terra/html/intersect.html)   

:::

:::{.callout-tip title="The ecologist mind"}
In which type of habitats were the otter observed? To answer this question, we will need to discover another type of spatial vector: **polygons**.
:::

## Setup

<details>
<summary> Follow the setup instructions if you haven't followed the tutorial on [points](https://frbcesab.github.io/spatial-r/chapters/11_points.html)</summary>

If haven't done it already, please follow the [setup instructions](https://frbcesab.github.io/spatial-r/chapters/01_setup.html). Let's start with loading the required packages.

```{r setting}
suppressPackageStartupMessages({
  library(mapview)
  library(here)
  library(sf)
  library(terra)
})
```

::: {.panel-tabset}

## local
```{r otter_local}
pt_otter <- vect(here("data", "gbif_otter_2021_mpl50km.gpkg"))
```

## online
```{r otter_online}
#| eval: false
pt_otter <- vect(
  "https://github.com/FRBCesab/spatial-r/raw/main/data/gbif_otter_2021_mpl50km.gpkg"
)
```

:::

</details>


## Load polygons from a shapefile

In this example, we will load land cover information for the area of interest from [IGN data BD CARTO](https://geoservices.ign.fr/bdcarto).

*Note that this dataset has rough resolution (OSO or Corine land cover would be more suited for real analysis), but it's perfect for our illustration and learning purposes.* 


::: {.panel-tabset}

## terra

You can load vector data with the function [`terra::vect()`](https://search.r-project.org/CRAN/refmans/terra/html/vect.html). 


```{r poly_local}
landuse <- vect(here("data", "BDCARTO-LULC_mpl50km.shp"))
```

## sf

```{r line_sf}
landuse_sf <- st_read(here("data", "BDCARTO-LULC_mpl50km.shp"))
```

## online
```{r poly_online}
#| eval: false
landuse <- vect(
  "https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDCARTO-LULC_mpl50km.shp"
)
```

:::


:::{.callout-note title="Your turn"}
1. How many different polygons make the land cover of the area?
2. What is the coordinate reference system (CRS) of the loaded river data?
3. How many land cover classes are there? which class has most polygons?
:::

<details>
<summary>Click to see the answer</summary>

1. There was ```r nrow(landuse)``` polygons in the dataset. You can access it with `dim(landuse)`, `nrow(landuse)` or just by typing `landuse` in the console.  
2. The coordinates are in ```r crs(landuse, describe = TRUE)$name``` (EPSG ```r crs(landuse, describe = TRUE)$code```). You can access this information with `crs(landuse, describe = TRUE)` (or in `sf` with `st_crs(landuse_sf)`).
3. The column that stored the cover classes is `nature`. You could identify it with `head(landuse)` or `names(landuse)`. There are ```r length(unique(landuse$nature))``` land cover classes,  ```r names(which.max(table(landuse$nature)))``` is the class with most polygons (`table(landuse$nature)`).

</details>


## Visualization

::: {.panel-tabset}

## interactive

```{r mapview_line}
mapview(landuse, z = "nature") +
  mapview(pt_otter, col.regions = "black")
```

## terra

```{r terramap_line}
plot(landuse, y = "nature", border = NA)
plot(pt_otter, add = TRUE)
```

## sf

```{r sfmap_line}
plot(landuse_sf["nature"], reset = FALSE, border = FALSE, axes = TRUE)
plot(pt_otter, add = TRUE, pch = 16)
```

:::{.callout-warning}
When you want to overlay multiple spatial object with base plot from `sf`, don't forget to use the argument `reset=FALSE`.
:::

:::

## Calculate area

:::{.callout-tip title="The ecologist mind"}
What is the dominant land cover in our study area?
:::

The function [`terra::expanse()`](https://search.r-project.org/CRAN/refmans/terra/html/expanse.html) calculates the area in $m^2$. When calculating areas, **be careful with projection systems**. Some are not suited to calculate areas. Prefer equal-area projections or use local projection system (if your study area is small). 

Luckily, the package `terra` calculates by default the geodesic area (based on lat/long coordinates and considering Earth's curvature) which is the best estimate and avoid errors due to wrongly used projection system.  


::: {.panel-tabset}

## terra

```{r lulc_area_terra}
# calculate the area in ha
area_polygons <- expanse(landuse) * 0.0001
# store the area as atribute
landuse$area_ha <- as.numeric(area_polygons)
```

## sf

For `sf`, it is recommended to project the dataset to a equal area projection, such as the Lambert azimuthal equal-area for Europe [EPSG:3035](https://epsg.io/3035).

```{r lulc_area_sf}
# 3035 is a equal-area projection for Europe
landuse_3035 <- st_transform(landuse_sf, crs = 3035)
# calculate area of polygons
area_polygons <- st_area(landuse_3035) * 0.0001
# store as attribute in landuse
landuse_3035$area_ha <- as.numeric(area_polygons)
```

:::


:::{.callout-note title="Your turn"}
- Which is the largest land cover class in our study area? Why?
:::

<details>
<summary>Click to see the answer</summary>

```{r ex1}
# see area per land use classes
tapply(landuse$area_ha, landuse$nature, sum)
```

The category `Eau libre` (=running water) is the largest land cover because, as it can be seen in the previous map, large part of the Mediterranean Sea is present in the land cover data.

</details>


## Mask the sea

:::{.callout-tip title="The ecologist mind"}
Our study area was defined as a buffer around Montpellier. This area include the marine ecosystems, which is not the habitat of otters. So it is recommended to mask the sea in order to consider only areas where otter could have been potentially spotted.
:::

There can be two approaches to mask an area: either (1) identify which area to remove from the data itself , or (2) use a mask from another data source (this approach will be [shown when dealing with rasters](https://frbcesab.github.io/spatial-r/chapters/21_rasters.html#mask-the-sea)). 

In this case, it is easier and more trustworthy to detect directly from the data which polygons to remove. In fact, the largest polygon correspond to the Mediterranean Sea. So we just need to remove it.

```{r ex2}
# the largest polygon correspond to the mediterranean
landuse$nature[which.max(landuse$area_ha)]
# remove the largest polygon
landuse_nomed <- landuse[-which.max(landuse$area_ha), ]
# visually verify the output
plot(landuse_nomed, y = "nature", border = NA)
```

Then we can recalculate the percentage of land cover per class.

```{r}
cover_ha <- tapply(landuse_nomed$area_ha, landuse_nomed$nature, sum)
# percentage of land cover classes in the terrestrial study area
cover_perc <- cover_ha / sum(cover_ha) * 100
#show rounded values
round(cover_perc, 2)
```


## Polygons to points

:::{.callout-tip title="The ecologist mind"}
What is the land cover class at the location of the otter observations?
:::

Before making extraction, it is recommended to plot the data (if not too big). This is a verification step ensuring that the projection systems and the extents match. Do not use `mapview` (interactive map) because it will automatically project the data.


::: {.panel-tabset}
## terra

Extract the land cover class of the points with [`terra::extract()`](https://search.r-project.org/CRAN/refmans/terra/html/extract.html): 
```{r lulc_otter_terra}
pt_landcover <- extract(landuse, pt_otter)
```

## sf
Extract the land cover class of the points with [`sf::st_join()`](https://search.r-project.org/CRAN/refmans/sf/html/st_join.html): 
```{r lulc_otter_sf}
pt_landcover <- st_join(st_as_sf(pt_otter), landuse_sf)
```

:::

```{r lulc_otter_table}
# see area per land use classes of the observations
table(pt_landcover$nature)
```

:::{.callout-note title="Your turn"}
- [stat] Which classes are over- or under- represented compare to the distribution of classes over the whole study area?
:::

<details>
<summary>Click to see the answer</summary>

```{r ex4}
# see area per land use classes of the observations
cover_obs_perc <- table(pt_landcover$nature) / nrow(pt_landcover) * 100
# add missing classes
m0 <- match(names(cover_perc), names(cover_obs_perc))
cover <- data.frame(
  class = names(cover_perc),
  all = as.numeric(cover_perc),
  obs = as.numeric(cover_obs_perc[m0])
)
# non matchin elements = 0
cover[is.na(cover)] <- 0
# calculate the difference between observed and expected
cover$delta <- cover$obs - cover$all
# add left margin to the plot
par(mar = c(4, 8, 4, 1))
barplot(
  cover$delta,
  horiz = TRUE,
  names = cover$class,
  las = 1,
  xlab = "Difference between observed and expected cover (%)"
)
```


</details>

## Polygons to polygons

:::{.callout-tip title="The ecologist mind"}
What is the land cover distribution around the locations of the otter observations?
:::

To characterize the area surrounding the observations, we need to define buffers. 

### Create buffer

::: {.panel-tabset}

## terra
We can create buffer with [`terra::buffer()`](https://search.r-project.org/CRAN/refmans/terra/html/buffer.html).

```{r buffer_terra}
dist_buffer <- 1000 # buffer of 1000 m
poly_otter <- buffer(pt_otter, dist_buffer)
```

## sf

:::{.callout-warning}
`sf` uses `s2` when the coordinates are geographic (e.g. EPSG:4326) which creates buffers with low quality (in `sf 1.0-21`, tested on 03/11/2025).  
It is recommended to use projected coordinates when using the function [`sf::st_buffer()`](https://search.r-project.org/CRAN/refmans/sf/html/geos_unary.html).
:::


```{r buffer_sf}
dist_buffer <- 1000 # buffer of 1000 m
# transform as UTM : better for area
pt_otter_3035 <- st_as_sf(pt_otter) |> st_transform(3035)
poly_otter_3035 <- st_buffer(pt_otter_3035, dist_buffer)
```

:::


### Visualize buffer

For illustration, we only show the buffer around the first observation.

The parameter `ext` limit the map to the extent of the given spatial object.  

```{r map_buffer_terra}
plot(landuse, y = "nature", ext = poly_otter[1])
plot(poly_otter[1], lwd = 2, add = TRUE)
plot(pt_otter[1], col = "red", add = TRUE)
```


:::{.callout-note title="Your turn"}
- What are the areas of the newly created buffers? 
:::

<details>
<summary>Click to see the answer</summary>

```{r ex5}
# see area per land use classes of the observations
summary(expanse(poly_otter))
# for sf
summary(st_area(poly_otter_3035))
```

The difference with expected value (```r print(pi*1000000)```) is due to the way the circle is defined (in 40 points in `terra` and 120 points in `sf`). 
</details>


### Intersection

::: {.panel-tabset}

## terra
```{r buffer_lulc_terra}
buffer_landcover <- intersect(landuse, poly_otter)

# visualize the intersection (not plotted to lighten the webpage)
# mapview(buffer_landcover, z = "nature")

# show a zoom on the land cover of the first buffer
plot(
  buffer_landcover[buffer_landcover$key %in% poly_otter$key[1]],
  y = "nature"
)
```

## sf
```{r buffer_lulc_sf}
buffer_landcover_sf <- st_intersection(poly_otter_3035, landuse_3035)

# visualize the intersection (not plotted to lighten the webpage)
# mapview(buffer_landcover, z = "nature")
```

:::

### Land cover per buffer 

We need to update the area of the intersected land cover.

```{r perc_lulc_terra}
# Calculate area for each polygon
buffer_landcover$area_ha <- expanse(buffer_landcover) * 0.0001

# Calculate area per buffer and nature class
class_area <- tapply(
  buffer_landcover$area_ha,
  list(buffer_landcover$key, buffer_landcover$nature),
  sum
)
#replace NA by 0
class_area[is.na(class_area)] <- 0
# calculate the area of the buffer that intersect any polygon
sum_area <- rowSums(class_area)
# calculate the percentage per class
perc_class <- class_area / sum_area * 100

# add margin at the bottom
par(mar = c(7, 4, 1, 1))
barplot(apply(perc_class, 2, mean), las = 2, ylab = "Percentage land cover")
```


