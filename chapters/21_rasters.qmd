# Rasters {.unnumbered}

:::{.callout-important title="Summary"}
This tutorial explores how to handle **rasters** in {{< fa brands r-project >}} with `terra` package:

- import a raster file with [`terra::rast()`](https://search.r-project.org/CRAN/refmans/terra/html/rast.html)   
- mask non relevant areas with [`terra::mask()`](https://search.r-project.org/CRAN/refmans/terra/html/mask.html)  
- create buffers around points with [`terra::buffer()`](https://search.r-project.org/CRAN/refmans/terra/html/buffer.html)  
- extract information from rasters on points or polygons with [`terra::extract()`](https://search.r-project.org/CRAN/refmans/terra/html/extract.html)

:::

:::{.callout-tip title="The ecologist mind"}
Elevation is a key geographical variable that strongly define habitats. At which elevation were the otter observed?
To answer this question, we will need to discover another type of spatial data: **rasters**.
:::

## Setup

<details>
<summary> Follow the setup instructions if you haven't followed the previous tutorials</summary>

If haven't done it already, please follow the [setup instructions](https://frbcesab.github.io/spatial-r/chapters/01_setup.html).  

Let's start with loading the required packages.  

```{r setting}
suppressPackageStartupMessages({
  library(mapview)
  library(here)
  library(terra)
  # library(sf)
  # library(exactextractr)
})
```

Load the observations of otters recorded in 2021 within a 50km buffer from Montpellier, France.  

::: {.panel-tabset}

## local
```{r otter_local}
pt_otter <- vect(here("data", "gbif_otter_2021_mpl50km.gpkg"))
```

## online
```{r otter_online}
#| eval: false
url_github <- "https://github.com/FRBCesab/spatial-r/raw/main/data/"
pt_otter <- vect(paste0(url_github, "gbif_otter_2021_mpl50km.gpkg"))
```

:::


## Load raster from a geotiff file

We will use the elevation data from [IGN data BD ALTI](https://geoservices.ign.fr/bdalti) which was aggregated at 250m resolution (instead of its original resolution of 25m). *Note that the rough resolution of this dataset is perfect for our learning purpose. Yet for real analyses, you might consider finer spatial data.* 
The function to read [most kind of raster file] is [`terra::rast()`](https://search.r-project.org/CRAN/refmans/terra/html/rast.html)

::: {.panel-tabset}

## local
```{r rast_local}
bdalti <- rast(here("data", "BDALTI_mpl50km.tif"))
```

## online
```{r rast_online}
#| eval: false
bdalti <- rast(
  "https://github.com/FRBCesab/spatial-r/raw/refs/heads/main/data/BDALTI_mpl50km.tif"
)
```

:::

## Rasters characteristics

```{r rast_summary}
bdalti
```

The loaded raster is projected in ```r crs(bdalti, describe = TRUE)$name``` (EPSG ```r crs(bdalti, describe = TRUE)$code```). It is a matrix with ```r nrow(bdalti)``` rows, ```r ncol(bdalti)``` columns, and a spatial resolution of ```r res(bdalti)[1]```m (on x and y). All the information about `terra::SpatRaster` can be accessed individually. Use [`terra::crs()`](https://search.r-project.org/CRAN/refmans/terra/html/ext.html) for the projection system, [`terra::ext()`](https://search.r-project.org/CRAN/refmans/terra/html/ext.html) for the geographical extent, [`terra::res()`](https://search.r-project.org/CRAN/refmans/terra/html/dimensions.html) for the resolution, and `dim()` for the dimensions (number of rows, number of columns and number of layers). 

```{r rast_name}
# get the name of the layer
names(bdalti)
# rename the layer (for simplicity)
names(bdalti) <- "elevation"
```

We can access all values of the raster with the function [`terra::values()`]((https://search.r-project.org/CRAN/refmans/terra/html/values.html)). This operation is often not needed and it is not recommended if you have large rasters. But it is the only way to get the distribution of all values.

```{r rast_values}
# get all the values : values()
# use only for small raster
# else it takes large amount of time and memory
boxplot(values(bdalti), ylab = "elevation (m)")
# mean elevation in our study area
summary(values(bdalti))
```

## Visualization

Similar to vectors, rasters can be visualized as static map with the function [`plot()`](https://search.r-project.org/CRAN/refmans/terra/html/plot.html) or interactively with the package `mapview`.

::: {.panel-tabset}

## static
```{r rast_mapstatic}
plot(bdalti)
```

## interactive
```{r rast_mapint}
mapview(bdalti)
```

:::


## Mask the sea

:::{.callout-tip title="The ecologist mind"}
To avoid considering regions outside the habitats, it is recommended to mask areas that are not part of the habitats (typically the sea for terrestrial animals). 
:::


To mask all pixels that don't fit our study area (the terrestrial environment 50km around Montpellier), we need (1) to get the borders of France from [GADM](https://gadm.org/), (2) project the border to match the elevation raster, (3) mask the area that are not in the polygon.

::: {.panel-tabset}

## local
```{r local_mask}
# get the border of the country
france_border <- readRDS(here("data", "gadm41_FRA_0_pk.rds"))
```

## geodata
```{r geodata_mask}
#| eval: false
# get the border of the country (level = 0)
france_border <- geodata::gadm("FRA", level = 0, path = here("data"))
```

:::


```{r mask_sea}
# project the coast in Lambert-93
france_2154 <- project(france_border, crs(bdalti))

# mask (=set to NA) the pixels that are not in the polygon
alti_masked <- mask(bdalti, france_2154)

plot(alti_masked)

# mean elevation in our study area (excluding sea)
summary(values(alti_masked), na.rm = TRUE)
```



## Raster to points

:::{.callout-tip title="The ecologist mind"}
Now that we have loaded the elevation data in R, let's get the elevation at the location of the otter observations. 
:::

### Checking projections and extent   

Remember that before comparing two spatial objects, it is always a good idea to map them together.

```{r plot_check}
plot(alti_masked)
plot(pt_otter, add = TRUE)
```

:::{.callout-note title="Your turn"}
Why can't you see the otter observations? How to fix this problem?  
:::

<details>
<summary>Click to see the answer</summary>

Indeed, the spatial points with the otter observations don't share the same projection than the elevation raster. We need to project the spatial points to the CRS of the elevation data. 

:::{.callout-important}
It is not recommended to project raster objects. When you have the choice, it is always better to project vector data to the raster projection system.
:::

```{r ex1}
# the projection systems are not matching
crs(bdalti) == crs(pt_otter)

# so we need to to project the otter observations to the raster's CRS
pt_2154 <- project(pt_otter, crs(bdalti))

# now we can check that the points overlay the elevation data
plot(alti_masked)
plot(pt_2154, col = "red", add = TRUE)
```

</details>

### Extraction of values

Now we can use the function [`terra::extract()`](https://search.r-project.org/CRAN/refmans/terra/html/extract.html) to get the elevation of the observations.

```{r ext_pts_rast}
pt_alti <- extract(alti_masked, pt_2154)

# visualize the extracted values
boxplot(pt_alti$elevation, ylab = "elevation (m)")
```


:::{.callout-note title="Your turn"}
1. Compare the extracted elevation with the elevation provided with GBIF (in the attribute table of the points). 
2. Are otters changing their elevation distribution depending on the time of the year? In other words, can we see differences in elevation depending on the time of the year in which the observations were made?
:::

<details>
<summary>Click to see the answer 1</summary>

```{r ex2}
# check with recorded
plot(
  pt_alti$elevation,
  pt_otter$elevation,
  xlab = "elevation (m) GBIF values",
  ylab = "elevation (m) BDALTI values",
  asp = 1
)
# add identity line
abline(a = 0, b = 1)
```

</details>

<details>
<summary>Click to see the answer 2</summary>

```{r ex3}
boxplot(
  pt_alti$elevation ~ pt_otter$month,
  xlab = "elevation (m)",
  ylab = "Month of observation"
)
```

</details>


## Raster to polygons

:::{.callout-tip title="The ecologist mind"}
What is the elevation around the locations of the otter observations?
:::

### Create buffer

We can create buffer with [`terra::buffer()`](https://search.r-project.org/CRAN/refmans/terra/html/buffer.html). It is recommended to work on geographic coordinates (latitude/longitude), or in an equal-area projection (which is not the case of Lambert-93). Hence, we first create the buffer in lat/long and then project them in Lambert-93.

```{r buffer_terra}
dist_buffer <- 1000 # buffer of 1000 m
poly_otter <- buffer(pt_otter, dist_buffer)
# project to Lambert-93
poly_2154 <- project(poly_otter, crs(bdalti))
```


:::{.callout-note title="Nerdy"}
- Curious to know why it is recommended to create buffer in lat/long with `terra`? Try it out. Create buffer in Lambert-93 and check whether all buffers have the same size.
:::

<details>
<summary>Click to see the answer</summary>

```{r ex4}
# create buffer directly in Lamber 93
buffer_2154 <- buffer(pt_2154, 1000)
# get the standard deviation of the area of the buffers
sd(expanse(buffer_2154))
# and compare it with the buffers created in lat/long
sd(expanse(poly_2154))
```

</details>


### Get average elevation

The function [`terra::extract()`](https://search.r-project.org/CRAN/refmans/terra/html/extract.html) can summarize the information per polygon with the parameter `fun`. If no function is provided, it will extract all values that intersect the polygons.   

It is recommended to use the parameter `exact=TRUE` to get the weighted mean based on the fraction of each cell that is covered (but that slows the computation).  

```{r ext_poly_rast_mean}
mean_alti <- extract(alti_masked, poly_2154, fun = mean, exact = TRUE)

plot(
  mean_alti$elevation,
  pt_otter$elevation,
  xlab = "mean elevation in buffer (m)",
  ylab = "elevation at the location of the observation (m)"
)
```



### Get all values within buffers

To understand how the function `extract` works, it is helpful to extract all values.

```{r ext_poly_rast_all}
full_alti <- extract(alti_masked, poly_2154, exact = TRUE)
head(full_alti)
```

Each row is a cell that is matching a polygon. `elevation` is the elevation value of the cell, `fraction` is the fraction of the cell covered by the polygon, and `ID` is the identifier of the intersecting polygon.    

We can calculate the number of different pixels that intersects the polygon.

```{r ext_all_npixels}
npixels <- table(full_alti$ID)
table(npixels) # it overlap between 63 and 69 pixels
```

The polygons intersect between 63 and 69 pixels, but some are partially intersecting. Let's now calculate the surface (in number of pixels) covered by the buffer

```{r ext_all_area}
area_per_id <- tapply(full_alti$fraction, full_alti$ID, sum)
summary(area_per_id)
```

The buffers cover an area equivalent to 50 full pixels.  

An interesting ecological variable that we can calculate with data for each pixel is the range of the elevation found within the buffer.  

```{r ext_all_range}
drange_alti <- tapply(full_alti$elevation, full_alti$ID, function(x) {
  diff(range(x))
})

plot(
  mean_alti$elevation,
  drange_alti,
  xlab = "mean elevation in buffer (m)",
  ylab = "elevation range in buffer (m)"
)
```








